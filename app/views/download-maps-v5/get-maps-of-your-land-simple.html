{% extends "layouts/main.html" %}

{% block pageTitle %}
  Simple Map Test - DEFRA Component
{% endblock %}

{% block head %}
  {{ super() }}
  <!-- DEFRA Interactive Map Component CSS -->
  <link rel="stylesheet" href="/plugin-assets/%40defra%2Finteractive-map/dist/css/index.css">
  <link rel="stylesheet" href="/plugin-assets/%40defra%2Finteractive-map/plugins/map-styles/dist/css/index.css">
  <link rel="stylesheet" href="/plugin-assets/%40defra%2Finteractive-map/plugins/search/dist/css/index.css">
  <link rel="stylesheet" href="/plugin-assets/%40defra%2Finteractive-map/plugins/scale-bar/dist/css/index.css">
  <link rel="stylesheet" href="/plugin-assets/%40defra%2Finteractive-map/plugins/datasets/dist/css/index.css">
  <link rel="stylesheet" href="/plugin-assets/%40defra%2Finteractive-map/plugins/interact/dist/css/index.css">
{% endblock %}

{% block content %}
<h1 class="govuk-heading-l">Simple Map Test</h1>
<p class="govuk-body">This is a simplified version of POC-5 with no custom layout CSS to test DEFRA component visibility.</p>

<!-- Simple map container - no custom positioning -->
<div id="map" class="im-is-loading" style="height: 600px; width: 100%;"></div>

<div class="govuk-!-margin-top-4">
  <h2 class="govuk-heading-m">Land Cover Layers</h2>
  <p class="govuk-body-s">Each layer shows a color fill with a distinguishing pattern for accessibility.</p>
  <div id="land-covers-list">
    <p class="govuk-body-s">Loading land cover data...</p>
  </div>

  <h2 class="govuk-heading-m govuk-!-margin-top-4">Other Layers</h2>
  <div class="govuk-checkboxes govuk-checkboxes--small">
    <div class="govuk-checkboxes__item">
      <input class="govuk-checkboxes__input" id="test-hedgerows" name="test-hedgerows" type="checkbox">
      <label class="govuk-label govuk-checkboxes__label" for="test-hedgerows">
        Hedgerows
      </label>
    </div>
  </div>
</div>

{% endblock %}

{% block pageScripts %}
<!-- DEFRA Interactive Map Component JS -->
<script src="/plugin-assets/%40defra%2Finteractive-map/dist/umd/index.js"></script>
<script src="/plugin-assets/%40defra%2Finteractive-map/providers/maplibre/dist/umd/index.js"></script>
<script src="/plugin-assets/%40defra%2Finteractive-map/plugins/map-styles/dist/umd/index.js"></script>
<script src="/plugin-assets/%40defra%2Finteractive-map/plugins/search/dist/umd/index.js"></script>
<script src="/plugin-assets/%40defra%2Finteractive-map/plugins/scale-bar/dist/umd/index.js"></script>
<script src="/plugin-assets/%40defra%2Finteractive-map/plugins/datasets/dist/umd/index.js"></script>
<script src="/plugin-assets/%40defra%2Finteractive-map/plugins/interact/dist/umd/index.js"></script>
<script src="/public/javascripts/request.js"></script>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // =====================================================
    // DATA CONFIGURATION
    // =====================================================
    const SBI = '{{ data['sbi'] | default('106332870') }}';
    let landParcelsData = null;
    let landCoversData = null;
    let hedgeControlData = null;
    let mapInstance = null;
    let datasetsReady = false;

    const landCoverColors = {
      'Permanent Grassland': '#00703c',
      'Arable Land': '#d4351c',
      'Temporary Grassland': '#85994b',
      'Woodland': '#005a30',
      'Scrub - Ungrazeable': '#f47738',
      'Notional - Scrub': '#fd0',
      'Track - Natural Surface': '#b58840',
      'Metalled track': '#505a5f',
      'Residential Gardens': '#912b88',
      'Hard Standings': '#626a6e',
      'Farm Building': '#b1b4b6',
      'Permanent Crops': '#4c2c92',
      'Fallow': '#f3f2f1',
      'Fallow Land': '#f3f2f1',
      'default': '#1d70b8'
    };

    // Pattern type for each land cover (used for accessibility)
    const landCoverPatterns = {
      'Permanent Grassland': 'diagonal-hatch',
      'Arable Land': 'crosshatch',
      'Temporary Grassland': 'horizontal-lines',
      'Woodland': 'dense-dots',
      'Scrub - Ungrazeable': 'vertical-lines',
      'Notional - Scrub': 'sparse-dots',
      'Track - Natural Surface': 'dashes',
      'Metalled track': 'dashes',
      'Residential Gardens': 'diagonal-reverse',
      'Hard Standings': 'grid',
      'Farm Building': 'grid',
      'Permanent Crops': 'circles',
      'Fallow': 'stipple',
      'Fallow Land': 'stipple'
    };

    // Track active land covers for style change re-application
    // Map<landCoverType, { datasetId, features }>
    const activeLandCovers = new Map();

    // =====================================================
    // PATTERN GENERATION
    // =====================================================

    // Create a tileable pattern image on a transparent background
    function createPattern(type, size) {
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, size, size);
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.65)';
      ctx.fillStyle = 'rgba(0, 0, 0, 0.65)';
      ctx.lineWidth = 1.5;

      switch (type) {
        case 'diagonal-hatch':
          for (let i = -size; i < size * 2; i += 8) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i + size, size);
            ctx.stroke();
          }
          break;
        case 'crosshatch':
          for (let i = -size; i < size * 2; i += 8) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i + size, size);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(i + size, 0);
            ctx.lineTo(i, size);
            ctx.stroke();
          }
          break;
        case 'horizontal-lines':
          for (let y = 0; y < size; y += 8) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(size, y);
            ctx.stroke();
          }
          break;
        case 'dense-dots':
          for (let x = 2; x < size; x += 6) {
            for (let y = 2; y < size; y += 6) {
              ctx.beginPath();
              ctx.arc(x, y, 1.5, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          break;
        case 'vertical-lines':
          for (let x = 0; x < size; x += 8) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, size);
            ctx.stroke();
          }
          break;
        case 'sparse-dots':
          for (let x = 5; x < size; x += 10) {
            for (let y = 5; y < size; y += 10) {
              ctx.beginPath();
              ctx.arc(x, y, 1.5, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          break;
        case 'dashes':
          ctx.setLineDash([6, 4]);
          for (let y = 4; y < size; y += 8) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(size, y);
            ctx.stroke();
          }
          ctx.setLineDash([]);
          break;
        case 'grid':
          for (let i = 0; i < size; i += 8) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, size);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(size, i);
            ctx.stroke();
          }
          break;
        case 'diagonal-reverse':
          for (let i = -size; i < size * 2; i += 8) {
            ctx.beginPath();
            ctx.moveTo(i + size, 0);
            ctx.lineTo(i, size);
            ctx.stroke();
          }
          break;
        case 'circles':
          ctx.lineWidth = 1;
          for (let x = 6; x < size; x += 12) {
            for (let y = 6; y < size; y += 12) {
              ctx.beginPath();
              ctx.arc(x, y, 3, 0, Math.PI * 2);
              ctx.stroke();
            }
          }
          break;
        case 'stipple': {
          const positions = [
            [2,3],[8,1],[15,5],[22,2],[28,6],
            [5,10],[12,8],[19,12],[25,9],[30,11],
            [1,16],[7,14],[14,18],[20,15],[27,17],
            [4,22],[10,20],[17,24],[23,21],[29,23],
            [3,28],[9,26],[16,30],[22,27],[28,29]
          ];
          positions.forEach(([x, y]) => {
            if (x < size && y < size) {
              ctx.beginPath();
              ctx.arc(x, y, 1.2, 0, Math.PI * 2);
              ctx.fill();
            }
          });
          break;
        }
      }
      return ctx.getImageData(0, 0, size, size);
    }

    // Register all unique pattern images with MapLibre
    function registerPatterns(map) {
      const patternSize = 32;
      const registered = new Set();
      Object.values(landCoverPatterns).forEach(patternType => {
        if (registered.has(patternType)) return;
        registered.add(patternType);
        const patternId = `pattern-${patternType}`;
        if (map.hasImage(patternId)) return;
        const imageData = createPattern(patternType, patternSize);
        map.addImage(patternId, { width: patternSize, height: patternSize, data: imageData.data });
      });
    }

    // Add a fill-pattern overlay layer for a land cover dataset
    function addPatternOverlay(map, datasetId, landCoverType, features) {
      const patternType = landCoverPatterns[landCoverType];
      if (!patternType || !map) return;
      const sourceId = `${datasetId}-pattern-source`;
      const layerId = `${datasetId}-pattern`;
      if (map.getLayer(layerId)) map.removeLayer(layerId);
      if (map.getSource(sourceId)) map.removeSource(sourceId);
      map.addSource(sourceId, {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: features }
      });
      map.addLayer({
        id: layerId,
        type: 'fill',
        source: sourceId,
        paint: {
          'fill-pattern': `pattern-${patternType}`,
          'fill-opacity': 0.7
        }
      });
    }

    // Remove a fill-pattern overlay layer
    function removePatternOverlay(map, datasetId) {
      const layerId = `${datasetId}-pattern`;
      const sourceId = `${datasetId}-pattern-source`;
      if (map.getLayer(layerId)) map.removeLayer(layerId);
      if (map.getSource(sourceId)) map.removeSource(sourceId);
    }

    // Draw a color + pattern swatch on a small canvas element
    function drawPatternSwatch(canvas, patternType, color) {
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, w, h);
      if (patternType) {
        const patternData = createPattern(patternType, 32);
        const tmp = document.createElement('canvas');
        tmp.width = 32;
        tmp.height = 32;
        tmp.getContext('2d').putImageData(patternData, 0, 0);
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = ctx.createPattern(tmp, 'repeat');
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
      }
    }

    // Populate land cover checkboxes from fetched data
    function populateLandCoverCheckboxes() {
      const container = document.getElementById('land-covers-list');
      if (!container || !landCoversData) return;

      const landCoverCounts = {};
      landCoversData.features.forEach(f => {
        const type = f.properties.DESCRIPTION;
        landCoverCounts[type] = (landCoverCounts[type] || 0) + 1;
      });

      const types = Object.keys(landCoverCounts).sort();

      const html = types.map(type => {
        const id = type.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
        const count = landCoverCounts[type];
        const color = landCoverColors[type] || landCoverColors['default'];
        return `
          <div class="govuk-checkboxes__item">
            <input class="govuk-checkboxes__input land-cover-checkbox"
                   id="land-cover-${id}"
                   name="land-cover"
                   type="checkbox"
                   value="${type}">
            <label class="govuk-label govuk-checkboxes__label" for="land-cover-${id}">
              <canvas class="land-cover-swatch" data-type="${type}" data-color="${color}" width="20" height="20"
                style="vertical-align: middle; margin-right: 4px; border: 1px solid #0b0c0c;"></canvas>
              ${type} (${count})
            </label>
          </div>`;
      }).join('');

      container.innerHTML = '<div class="govuk-checkboxes govuk-checkboxes--small">' + html + '</div>';

      // Draw swatches
      document.querySelectorAll('.land-cover-swatch').forEach(canvas => {
        const type = canvas.dataset.type;
        drawPatternSwatch(canvas, landCoverPatterns[type], canvas.dataset.color);
      });

      // Wire up checkboxes
      document.querySelectorAll('.land-cover-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          if (!datasetsReady) return;
          const landCoverType = this.value;
          const datasetId = 'land-cover-' + landCoverType.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();

          if (this.checked) {
            const filteredFeatures = landCoversData.features.filter(
              f => f.properties.DESCRIPTION === landCoverType
            );
            if (filteredFeatures.length === 0) return;

            const color = landCoverColors[landCoverType] || landCoverColors['default'];
            datasetsPlugin.addDataset({
              id: datasetId,
              label: landCoverType,
              geojson: { type: 'FeatureCollection', features: filteredFeatures },
              fill: color,
              stroke: '#0b0c0c',
              strokeWidth: 1.5,
              showInKey: true,
              showInLayers: false,
              minZoom: 0,
              maxZoom: 24
            });
            addPatternOverlay(mapInstance, datasetId, landCoverType, filteredFeatures);
            activeLandCovers.set(landCoverType, { datasetId, features: filteredFeatures });
            console.log('Added land cover:', landCoverType);
          } else {
            datasetsPlugin.removeDataset(datasetId);
            removePatternOverlay(mapInstance, datasetId);
            activeLandCovers.delete(landCoverType);
            console.log('Removed land cover:', landCoverType);
          }
        });
      });
    }

    // =====================================================
    // DATA FETCHING
    // =====================================================
    async function fetchLandParcels() {
      try {
        const url = `https://environment.data.gov.uk/data-services/RPA/LandParcels/wfs?version=2.0.0&request=GetFeature&typeNames=RPA:LandParcels&cql_filter=SBI=${SBI}&srsname=EPSG:4326&outputFormat=application/json`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`API request failed: ${response.status}`);
        const data = await response.json();
        data.features.forEach(feature => {
          feature.properties.ngc = `${feature.properties.SHEET_ID}${feature.properties.PARCEL_ID}`;
        });
        console.log('Loaded parcels:', data.features.length);
        return data;
      } catch (error) {
        console.error('Error fetching land parcels:', error);
        return null;
      }
    }

    async function fetchLandCovers() {
      try {
        const url = `https://environment.data.gov.uk/data-services/RPA/LandCovers/wfs?version=2.0.0&request=GetFeature&typeNames=RPA:LandCovers&cql_filter=SBI=${SBI}&srsname=EPSG:4326&outputFormat=application/json`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`API request failed: ${response.status}`);
        const data = await response.json();
        console.log('Loaded land covers:', data.features.length);
        return data;
      } catch (error) {
        console.error('Error fetching land covers:', error);
        return null;
      }
    }

    async function fetchHedgeControl() {
      try {
        const url = `https://environment.data.gov.uk/data-services/RPA/HedgeControl/wfs?version=2.0.0&request=GetFeature&typeNames=RPA:HedgeControl&cql_filter=SBI=${SBI}&srsname=EPSG:4326&outputFormat=application/json`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`API request failed: ${response.status}`);
        const data = await response.json();
        console.log('Loaded hedgerows:', data.features.length);
        return data;
      } catch (error) {
        console.error('Error fetching hedge control:', error);
        return null;
      }
    }

    // =====================================================
    // ADD PARCELS TO MAP
    // =====================================================
    function addParcelsToMap(map, data) {
      if (!data || !data.features || data.features.length === 0) return;

      map.addSource('parcels', {
        type: 'geojson',
        data: data,
        promoteId: 'ngc'
      });

      map.addLayer({
        id: 'parcels-fill',
        type: 'fill',
        source: 'parcels',
        paint: {
          'fill-color': '#1d70b8',
          'fill-opacity': 0
        }
      });

      map.addLayer({
        id: 'parcels-outline',
        type: 'line',
        source: 'parcels',
        paint: {
          'line-color': '#1d70b8',
          'line-width': 2
        }
      });

      // Enable interact plugin
      console.log('Enabling interact plugin...');
      interactPlugin.enable();

      // Calculate bounds and fit
      let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;
      data.features.forEach(feature => {
        const processCoords = (coords) => {
          coords.forEach(coord => {
            if (Array.isArray(coord[0])) {
              processCoords(coord);
            } else {
              minLng = Math.min(minLng, coord[0]);
              maxLng = Math.max(maxLng, coord[0]);
              minLat = Math.min(minLat, coord[1]);
              maxLat = Math.max(maxLat, coord[1]);
            }
          });
        };
        processCoords(feature.geometry.coordinates);
      });

      map.fitBounds([[minLng, minLat], [maxLng, maxLat]], { padding: 50, duration: 0 });
      document.getElementById('map').classList.remove('im-is-loading');
    }

    // =====================================================
    // PLUGINS SETUP
    // =====================================================

    // Datasets plugin with placeholder for Key button
    const datasetsPlugin = defra.datasetsPlugin({
      datasets: [{
        id: 'placeholder',
        label: 'placeholder',
        geojson: { type: 'FeatureCollection', features: [] },
        showInKey: true,
        showInLayers: false,
        visibility: 'hidden'
      }]
    });

    // Interact plugin for parcel selection
    const interactPlugin = defra.interactPlugin({
      dataLayers: [{
        layerId: 'parcels-fill',
        idProperty: 'ngc',
        selectedFeatureStyle: {
          stroke: { outdoor: '#0b0c0c', dark: '#ffdd00' },
          'stroke-width': 3,
          fill: 'rgba(255, 221, 0, 0.5)'
        }
      }],
      interactionMode: 'select',
      multiSelect: true,
      closeOnDone: false,
      closeOnCancel: false
    });

    // =====================================================
    // INITIALIZE MAP
    // =====================================================
    const interactiveMap = new defra.InteractiveMap('map', {
      mapProvider: defra.maplibreProvider(),
      behaviour: 'inline',
      minZoom: 6,
      maxZoom: 20,
      enableZoomControls: true,
      containerHeight: '600px',
      mapStyle: {
        url: '{{ data.VTS_OUTDOOR_URL }}',
        attribution: `Contains OS data \u00A9 Crown copyright and database rights ${new Date().getFullYear()}`,
        backgroundColor: '#f5f5f0'
      },
      transformRequest: transformTileRequest,
      plugins: [
        defra.mapStylesPlugin({
          mapStyles: [
            {
              id: 'outdoor',
              label: 'Outdoor',
              url: '{{ data.VTS_OUTDOOR_URL }}',
              thumbnail: '/plugin-assets/%40defra%2Finteractive-map/assets/images/outdoor-map-thumb.jpg',
              logo: '/plugin-assets/%40defra%2Finteractive-map/assets/images/os-logo.svg',
              logoAltText: 'Ordnance Survey logo',
              attribution: `Contains OS data \u00A9 Crown copyright and database rights ${new Date().getFullYear()}`,
              backgroundColor: '#f5f5f0',
              mapColorScheme: 'light',
              appColorScheme: 'light'
            },
            {
              id: 'dark',
              label: 'Dark',
              url: '{{ data.VTS_DARK_URL }}',
              thumbnail: '/plugin-assets/%40defra%2Finteractive-map/assets/images/dark-map-thumb.jpg',
              logo: '/plugin-assets/%40defra%2Finteractive-map/assets/images/os-logo-white.svg',
              logoAltText: 'Ordnance Survey logo',
              attribution: `Contains OS data \u00A9 Crown copyright and database rights ${new Date().getFullYear()}`,
              backgroundColor: '#1a1a1a',
              mapColorScheme: 'dark',
              appColorScheme: 'dark'
            },
            {
              id: 'black-and-white',
              label: 'Black/White',
              url: '{{ data.VTS_BLACK_AND_WHITE_URL }}',
              thumbnail: '/plugin-assets/%40defra%2Finteractive-map/assets/images/black-and-white-map-thumb.jpg',
              logo: '/plugin-assets/%40defra%2Finteractive-map/assets/images/os-logo.svg',
              logoAltText: 'Ordnance Survey logo',
              attribution: `Contains OS data \u00A9 Crown copyright and database rights ${new Date().getFullYear()}`,
              backgroundColor: '#f5f5f0',
              mapColorScheme: 'light',
              appColorScheme: 'light'
            },
            {
              id: 'satellite',
              label: 'Satellite',
              url: '/satellite-style.json',
              thumbnail: '/plugin-assets/%40defra%2Finteractive-map/assets/images/outdoor-map-thumb.jpg',
              attribution: '\u00A9 Esri, Maxar, Earthstar Geographics',
              backgroundColor: '#1a1a1a',
              mapColorScheme: 'dark',
              appColorScheme: 'dark'
            }
          ]
        }),
        interactPlugin,
        datasetsPlugin,
        defra.searchPlugin({
          osNamesURL: '/api/geocode-proxy?query={query}',
          width: '300px',
          showMarker: true,
          isExpanded: false
        }),
        defra.scaleBarPlugin({ units: 'metric' })
      ]
    });

    window.interactiveMap = interactiveMap;

    // =====================================================
    // EVENT HANDLERS
    // =====================================================
    interactiveMap.on('datasets:ready', () => {
      console.log('Datasets plugin ready');
      datasetsReady = true;
    });

    interactiveMap.on('interact:selectionchange', (e) => {
      console.log('Selection changed:', e.selectedFeatures?.length || 0, 'features selected');
    });

    interactiveMap.on('map:ready', async (e) => {
      mapInstance = e.map;
      console.log('Map ready');

      // Register fill patterns with MapLibre
      registerPatterns(mapInstance);

      // Fetch data
      const [parcelsData, coversData, hedgesData] = await Promise.all([
        fetchLandParcels(),
        fetchLandCovers(),
        fetchHedgeControl()
      ]);

      landParcelsData = parcelsData;
      landCoversData = coversData;
      hedgeControlData = hedgesData;

      if (parcelsData) {
        addParcelsToMap(mapInstance, parcelsData);
      }

      // Populate land cover checkboxes from fetched data
      if (landCoversData) {
        populateLandCoverCheckboxes();
      }
    });

    // Re-add parcels and patterns after style change
    interactiveMap.on('map:stylechange', (e) => {
      console.log('Style changed');
      setTimeout(() => {
        if (mapInstance) {
          // Re-register pattern images (lost on style change)
          registerPatterns(mapInstance);

          // Re-add parcels layer
          if (landParcelsData && !mapInstance.getSource('parcels')) {
            mapInstance.addSource('parcels', {
              type: 'geojson',
              data: landParcelsData,
              promoteId: 'ngc'
            });

            mapInstance.addLayer({
              id: 'parcels-fill',
              type: 'fill',
              source: 'parcels',
              paint: { 'fill-color': '#1d70b8', 'fill-opacity': 0 }
            });

            mapInstance.addLayer({
              id: 'parcels-outline',
              type: 'line',
              source: 'parcels',
              paint: { 'line-color': '#1d70b8', 'line-width': 2 }
            });

            interactPlugin.enable();
          }

          // Re-add active pattern overlay layers
          // (datasetsPlugin re-adds its own color fills; patterns need manual re-add)
          setTimeout(() => {
            activeLandCovers.forEach(({ datasetId, features }, landCoverType) => {
              addPatternOverlay(mapInstance, datasetId, landCoverType, features);
            });
          }, 300);
        }
      }, 500);
    });

    // =====================================================
    // HEDGEROWS TOGGLE
    // =====================================================
    document.getElementById('test-hedgerows').addEventListener('change', function() {
      if (!datasetsReady || !hedgeControlData) {
        console.warn('Not ready');
        return;
      }

      if (this.checked) {
        datasetsPlugin.addDataset({
          id: 'test-hedgerows',
          label: 'Hedgerows',
          geojson: hedgeControlData,
          stroke: '#912b88',
          strokeWidth: 3,
          showInKey: true,
          showInLayers: false,
          keySymbolShape: 'line',
          minZoom: 0,
          maxZoom: 24
        });
        console.log('Added hedgerows dataset');
      } else {
        datasetsPlugin.removeDataset('test-hedgerows');
        console.log('Removed hedgerows dataset');
      }
    });
  });
</script>
{% endblock %}
