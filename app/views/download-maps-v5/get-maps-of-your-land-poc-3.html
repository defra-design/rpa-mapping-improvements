{% extends "layouts/main.html" %}

{% from "govuk/components/service-navigation/macro.njk" import govukServiceNavigation %}

{% block header %}
  {{ govukHeader() }}
{{ govukServiceNavigation({
  serviceName: "Land and farm",
  serviceUrl: "#",
  navigation: [
    {
      href: "start",
      text: "Get maps of your land",
      active: true
    },
    {
      href: "#",
      text: "Register land"
    },
    {
      href: "#",
      text: "Transfer land"
    }
  ]
}) }}
{% endblock %}

{% set excludeBeforeContent = true %}

{% block head %}
  {{ super() }}
  <link href="https://unpkg.com/maplibre-gl@4/dist/maplibre-gl.css" rel="stylesheet">
{% endblock %}

{% block pageTitle %}
  Map - Get maps of your land – {{ serviceName }} – GOV.UK Prototype Kit
{% endblock %}

{% block content %}

<div class="app-full-width-container">
  <main>
    <div class="govuk-grid-row">
      <div class="govuk-grid-column-one-third">
        <!-- Title -->
        <h1 class="govuk-heading-m govuk-!-margin-bottom-2">Cannon Hall Farm</h1>

        <!-- Whole holding information -->
        <p class="govuk-body govuk-!-margin-bottom-1">
          Total area (ha) <span id="sidebar-total-area">0.0000</span>
        </p>
        <p class="govuk-body govuk-!-margin-bottom-0">
          Total parcels <span id="sidebar-total-parcels">0</span>
        </p>

        <!-- Accordion component for different views -->
        {% from "govuk/components/accordion/macro.njk" import govukAccordion %}

        {{ govukAccordion({
          id: "accordion-land-data",
          items: [
            {
              heading: {
                text: "Land parcels"
              },
              summary: {
                html: '<p class="govuk-body-s govuk-!-margin-bottom-1">Selected area (ha) <span id="sidebar-selected-area">0.0000</span></p><p class="govuk-body-s govuk-!-margin-bottom-0">Selected <span id="sidebar-selected-count">0 of 0</span></p>'
              },
              content: {
                html: '<div class="parcel-controls-row" style="margin-top: -10px;"><div class="govuk-form-group govuk-!-margin-bottom-0 filter-input-wrapper"><label class="govuk-label govuk-label--s govuk-!-margin-bottom-1" for="parcel-filter">Filter</label><input class="govuk-input" id="parcel-filter" name="parcelFilter" type="text"></div><div id="select-all-container"><div class="govuk-checkboxes govuk-checkboxes--small" data-module="govuk-checkboxes"><div class="govuk-checkboxes__item"><input class="govuk-checkboxes__input" id="select-all-parcels" name="selectAllParcels" type="checkbox"><label class="govuk-label govuk-checkboxes__label" for="select-all-parcels">Select all</label></div></div></div></div><div class="scrollable-checkbox-container" id="parcels-list"><p class="govuk-body-s">Loading</p></div>'
              },
              expanded: true
            },
            {
              heading: {
                text: "Land covers"
              },
              summary: {
                html: 'Selected <span id="land-covers-selected-count">0</span>'
              },
              content: {
                html: '<div class="scrollable-checkbox-container" id="land-covers-list"><!-- Will be populated dynamically by JavaScript --></div>'
              }
            },
            {
              heading: {
                text: "Hedgerows"
              },
              content: {
                html: '<div class="govuk-checkboxes govuk-checkboxes--small govuk-!-margin-bottom-3"><div class="govuk-checkboxes__item"><input class="govuk-checkboxes__input" id="hedgerows-checkbox" name="hedgerows" type="checkbox" value="hedgerows"><label class="govuk-label govuk-checkboxes__label" for="hedgerows-checkbox">Select all</label></div></div><div id="hedgerows-summary"><p class="govuk-body-s">Loading</p></div>'
              }
            }
          ]
        }) }}

        {% from "govuk/components/button/macro.njk" import govukButton %}
        {{ govukButton({
          text: "Download map",
          classes: ""
        }) }}

        <!-- <hr class="govuk-section-break govuk-section-break--m govuk-section-break--visible  govuk-!-static-margin-top-4 govuk-!-static-margin-bottom-2"> -->
      </div>
      <div class="govuk-grid-column-two-thirds">
        <!-- Map area -->
        <div style="position: relative;">
          <div id="map" style="width: 100%; height: 800px;"></div>

          <!-- Loading message -->
          <div id="map-loading" class="map-loading-overlay">
            <div class="map-loading-content">
              <h2 class="govuk-heading-m">Loading your land data</h2>
              <p class="govuk-body">Loading land parcels, land cover and hedgerow data...</p>
            </div>
          </div>

          <!-- Search overlay (toggle-able, hidden until map loads) -->
          <div id="search-overlay" class="map-overlay" style="display: none;">
            <button id="search-toggle" class="map-search-toggle" aria-label="Show search">
              <img src="/public/images/search.svg" alt="" aria-hidden="true">
            </button>

            <!-- Search input in overlay (hidden by default) -->
            <div id="search-container" style="display: none;">
              <form class="map-search-form" id="location-search-form">
                <div class="map-search-wrapper-with-close">
                  <input
                    class="govuk-input map-search-input-large"
                    id="location-search"
                    name="location-search"
                    type="text"
                    autocomplete="off"
                    placeholder="Search your land">
                  <button type="button" id="search-close" class="map-search-close" aria-label="Close search">×</button>
                </div>
              </form>

              <!-- Search results dropdown -->
              <div id="search-results" class="map-search-results-large" style="display: none;">
                <ul class="map-search-results-list" id="search-results-list">
                  <!-- Results will be populated here -->
                </ul>
              </div>
            </div>
          </div>

          <!-- Legend overlay (toggle-able, hidden until land covers enabled) -->
          <div id="legend-overlay" class="map-overlay" style="display: none;">
            <button id="legend-toggle" class="map-legend-toggle" aria-label="Show legend">
              <img src="/public/images/list.svg" alt="" aria-hidden="true">
            </button>

            <!-- Legend content (hidden by default) -->
            <div id="legend-container" class="map-legend" style="display: none;">
              <button type="button" id="legend-close" class="map-legend-close" aria-label="Close legend">×</button>
              <h3 class="govuk-heading-m govuk-!-margin-bottom-2">Key</h3>
              <div id="legend-content">
                <!-- Will be populated dynamically by JavaScript -->
                <p class="govuk-body-s">No features to display</p>
              </div>
            </div>
          <!-- End legend container -->
        </div>
        <!-- End legend overlay -->
        </div>
      </div>
    </div>
  </main>
</div>

{% endblock %}

{% block pageScripts %}
<script src="https://unpkg.com/maplibre-gl@4/dist/maplibre-gl.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Configuration
    // Land parcels
    // National Trust: 106327021 (13143 parcels)
    // 80 parcels: 106200212
    // 50 parcels: 106172811
    // 33 parcels: 106332870
    // 29 parcels: 106200859
    // UR 12 noon: 106432212 106936676
    // UR 9.30 am: 110438001
    const SBI = '106332870'; // Test SBI
    let landParcelsData = null;
    let landCoversData = null;
    let hedgeControlData = null;
    let parcelLayers = {};
    let cachedBounds = null; // Cache bounds calculation
    let landCoverTypes = []; // Store unique land cover types
    let activeLandCovers = new Set(); // Track which land covers are currently selected

    // Initialize the map
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        'version': 8,
        'sources': {
          'raster-tiles': {
            'type': 'raster',
            'tiles': [
              'https://tile.openstreetmap.org/{z}/{x}/{y}.png'
            ],
            'tileSize': 256,
            'attribution': '© OpenStreetMap contributors'
          }
        },
        'layers': [
          {
            'id': 'simple-tiles',
            'type': 'raster',
            'source': 'raster-tiles',
            'minzoom': 0,
            'maxzoom': 22
          }
        ]
      }
    });

    // Search marker
    let searchMarker = null;

    // Custom zoom controls will be added in HTML instead of MapLibre default

    // Add scale control
    map.addControl(new maplibregl.ScaleControl({
      maxWidth: 100,
      unit: 'metric'
    }), 'bottom-left');

    // Fetch land parcels from RPA API
    async function fetchLandParcels() {
      try {
        // Request data in EPSG:4326 (WGS84 lat/lng) which Maplibre uses natively
        const url = `https://environment.data.gov.uk/data-services/RPA/LandParcels/wfs?version=2.0.0&request=GetFeature&typeNames=RPA:LandParcels&cql_filter=SBI=${SBI}&srsname=EPSG:4326&outputFormat=application/json`;

        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }

        const data = await response.json();
        landParcelsData = data;

        console.log('Loaded parcels:', data);
        console.log('First feature coordinates:', data.features[0]?.geometry.coordinates);

        return data;
      } catch (error) {
        console.error('Error fetching land parcels:', error);
        document.getElementById('parcels-list').innerHTML =
          '<p class="govuk-body-s" style="color: #d4351c;">Error loading parcels. Please check console.</p>';
        return null;
      }
    }

    // Fetch land covers from RPA API
    async function fetchLandCovers() {
      try {
        const url = `https://environment.data.gov.uk/data-services/RPA/LandCovers/wfs?version=2.0.0&request=GetFeature&typeNames=RPA:LandCovers&cql_filter=SBI=${SBI}&srsname=EPSG:4326&outputFormat=application/json`;

        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }

        const data = await response.json();
        landCoversData = data;

        console.log('Loaded land covers:', data);

        // Extract unique land cover types from DESCRIPTION field
        const types = new Set();
        data.features.forEach(feature => {
          if (feature.properties && feature.properties.DESCRIPTION) {
            types.add(feature.properties.DESCRIPTION);
          }
        });
        landCoverTypes = Array.from(types).sort();
        console.log('Unique land cover types:', landCoverTypes);

        return data;
      } catch (error) {
        console.error('Error fetching land covers:', error);
        return null;
      }
    }

    // Fetch hedge control from RPA API
    async function fetchHedgeControl() {
      try {
        const url = `https://environment.data.gov.uk/data-services/RPA/HedgeControl/wfs?version=2.0.0&request=GetFeature&typeNames=RPA:HedgeControl&cql_filter=SBI=${SBI}&srsname=EPSG:4326&outputFormat=application/json`;

        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }

        const data = await response.json();
        hedgeControlData = data;

        console.log('Loaded hedge control:', data);

        return data;
      } catch (error) {
        console.error('Error fetching hedge control:', error);
        return null;
      }
    }

    // Add parcels to map
    function addParcelsToMap(data) {
      if (!data || !data.features || data.features.length === 0) {
        console.log('No parcel features found');
        return;
      }

      // Add source for all parcels
      map.addSource('land-parcels', {
        type: 'geojson',
        data: data
      });

      // Add fill layer for parcels
      map.addLayer({
        id: 'parcels-fill',
        type: 'fill',
        source: 'land-parcels',
        paint: {
          'fill-color': '#1d70b8', // GOV.UK blue
          'fill-opacity': 0.3
        }
      });

      // Add outline layer for parcels
      map.addLayer({
        id: 'parcels-outline',
        type: 'line',
        source: 'land-parcels',
        paint: {
          'line-color': '#1d70b8',
          'line-width': 2
        }
      });

      // Add highlight layer (initially empty) - SOURCE FIRST
      map.addSource('selected-parcels', {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: []
        }
      });

        // THEN add the layers with explicit visibility
        map.addLayer({
        id: 'selected-parcels-fill',
        type: 'fill',
        source: 'selected-parcels',
        paint: {
            'fill-color': '#ffdd00', // GOV.UK yellow
            'fill-opacity': 0.5
        },
        layout: {
            'visibility': 'visible'
        }
        });

        map.addLayer({
        id: 'selected-parcels-outline',
        type: 'line',
        source: 'selected-parcels',
        paint: {
            'line-color': '#0b0c0c', // GOV.UK black
            'line-width': 3
        },
        layout: {
            'visibility': 'visible'
        }
        });

      // Move selected layers to the top after a brief delay
      setTimeout(() => {
        if (map.getLayer('selected-parcels-fill')) {
          map.moveLayer('selected-parcels-fill');
        }
        if (map.getLayer('selected-parcels-outline')) {
          map.moveLayer('selected-parcels-outline');
        }
      }, 100);

      // Calculate and cache bounds
      if (!cachedBounds) {
        const bounds = new maplibregl.LngLatBounds();

        data.features.forEach(feature => {
          if (feature.geometry.type === 'Polygon') {
            feature.geometry.coordinates[0].forEach(coord => {
              bounds.extend(coord);
            });
          } else if (feature.geometry.type === 'MultiPolygon') {
            feature.geometry.coordinates.forEach(polygon => {
              polygon[0].forEach(coord => {
                bounds.extend(coord);
              });
            });
          }
        });

        cachedBounds = bounds;

        map.fitBounds(cachedBounds, {
          padding: 50,
          duration: 0  // Instant, no animation on initial load
        });

        // Show the map and hide loading overlay
        document.getElementById('map').classList.add('ready');

        // Hide loading overlay and show search toggle and legend toggle
        const loadingOverlay = document.getElementById('map-loading');
        const searchOverlay = document.getElementById('search-overlay');
        const legendOverlay = document.getElementById('legend-overlay');

        if (loadingOverlay) {
          loadingOverlay.style.display = 'none';
        }
        if (searchOverlay) {
          searchOverlay.style.display = 'block';
          searchOverlay.style.position = 'absolute';
          searchOverlay.style.top = '10px';
          searchOverlay.style.left = '10px';
          searchOverlay.style.zIndex = '15'; // Higher than legend overlay
        }
        if (legendOverlay) {
          legendOverlay.style.display = 'block';
          legendOverlay.style.position = 'absolute';
          legendOverlay.style.top = '64px'; // Increased gap to 20px to match map controls
          legendOverlay.style.left = '10px';
          legendOverlay.style.zIndex = '10';
        }
      }

      // Helper function: Check if point is inside polygon
      function pointInPolygon(point, polygon) {
        const [x, y] = point;
        let inside = false;

        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const [xi, yi] = polygon[i];
          const [xj, yj] = polygon[j];

          const intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

          if (intersect) inside = !inside;
        }

        return inside;
      }

      // Helper function: Check if point is inside any ring of a polygon/multipolygon
      function pointInFeature(point, feature) {
        const geom = feature.geometry;

        if (geom.type === 'Polygon') {
          // Check exterior ring (first ring)
          if (!pointInPolygon(point, geom.coordinates[0])) return false;

          // Check holes (remaining rings) - point should NOT be in holes
          for (let i = 1; i < geom.coordinates.length; i++) {
            if (pointInPolygon(point, geom.coordinates[i])) return false;
          }
          return true;

        } else if (geom.type === 'MultiPolygon') {
          // Check each polygon in the multipolygon
          for (const polygon of geom.coordinates) {
            if (!pointInPolygon(point, polygon[0])) continue;

            let inHole = false;
            for (let i = 1; i < polygon.length; i++) {
              if (pointInPolygon(point, polygon[i])) {
                inHole = true;
                break;
              }
            }

            if (!inHole) return true;
          }
          return false;
        }

        return false;
      }

      // Helper function: Calculate distance from point to line segment
      function pointToSegmentDistance(point, segmentStart, segmentEnd) {
        const [px, py] = point;
        const [x1, y1] = segmentStart;
        const [x2, y2] = segmentEnd;

        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) param = dot / lenSq;

        let xx, yy;

        if (param < 0) {
          xx = x1;
          yy = y1;
        } else if (param > 1) {
          xx = x2;
          yy = y2;
        } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;

        return Math.sqrt(dx * dx + dy * dy);
      }

      // Helper function: Check if point is near a LineString
      function pointNearLineString(point, lineString, threshold) {
        const coords = lineString.coordinates;

        for (let i = 0; i < coords.length - 1; i++) {
          const distance = pointToSegmentDistance(point, coords[i], coords[i + 1]);
          if (distance < threshold) return true;
        }

        return false;
      }

      // Unified click handler - combines parcel, land cover, and hedgerow info
      // Queries source data directly to work regardless of layer visibility
      if (!map._unifiedClickHandler) {
        let isProcessingClick = false;

        map._unifiedClickHandler = (e) => {
          // If already processing a click, ignore this one completely
          if (isProcessingClick) {
            console.log('Click ignored - already processing another click');
            return;
          }

          isProcessingClick = true;

          // Reset the flag after 100ms
          setTimeout(() => {
            isProcessingClick = false;
          }, 100);

          console.log('=== UNIFIED CLICK EVENT ===');

          const clickPoint = [e.lngLat.lng, e.lngLat.lat];

          // Query source data directly for all features at click point
          let parcelFeature = null;
          let landCoverFeatures = [];
          let hedgeFeatures = [];

          // Find parcel at click point
          if (landParcelsData && landParcelsData.features) {
            parcelFeature = landParcelsData.features.find(f => pointInFeature(clickPoint, f));
          }

          // Need at least a parcel to show popup
          if (!parcelFeature) {
            console.log('No parcel found at click point');
            return;
          }

          const parcelProps = parcelFeature.properties;
          console.log('Parcel clicked:', parcelProps);

          // Find all land covers for this parcel (if data is loaded)
          if (landCoversData && landCoversData.features) {
            landCoverFeatures = landCoversData.features.filter(f =>
              f.properties.SHEET_ID === parcelProps.SHEET_ID &&
              f.properties.PARCEL_ID === parcelProps.PARCEL_ID
            );
          }

          // Find all hedgerows for this parcel (if data is loaded)
          if (hedgeControlData && hedgeControlData.features) {
            hedgeFeatures = hedgeControlData.features.filter(f =>
              f.properties.REF_PARCEL_SHEET_ID === parcelProps.SHEET_ID &&
              f.properties.REF_PARCEL_PARCEL_ID === parcelProps.PARCEL_ID
            );
          }

          // Handle parcel selection logic
          let wasJustSelected = false;

          if (parcelFeature) {
            // Check if selected-parcels source exists
            const selectedSource = map.getSource('selected-parcels');
            if (!selectedSource) {
              console.error('selected-parcels source not found');
              return;
            }

            // Get current selected parcels
            const currentData = selectedSource._data;
            const currentFeatures = currentData.features || [];

            // Check if this parcel is already selected
            const parcelId = `${parcelProps.SHEET_ID}${parcelProps.PARCEL_ID}`;
            const existingIndex = currentFeatures.findIndex(f =>
              `${f.properties.SHEET_ID}${f.properties.PARCEL_ID}` === parcelId
            );

            let newFeatures;
            if (existingIndex !== -1) {
              // Parcel already selected - remove it (toggle off)
              newFeatures = currentFeatures.filter((f, i) => i !== existingIndex);
              wasJustSelected = false;
            } else {
              // Parcel not selected - add it
              newFeatures = [...currentFeatures, parcelFeature];
              wasJustSelected = true;
            }

            // Update the selected parcels
            selectedSource.setData({
              type: 'FeatureCollection',
              features: newFeatures
            });

            // Update statistics in sidebar
            const totalArea = newFeatures.reduce((sum, f) =>
              sum + parseFloat(f.properties.AREA_HA || 0), 0
            );
            document.getElementById('sidebar-selected-area').textContent = totalArea.toFixed(4);
            document.getElementById('sidebar-selected-count').textContent =
              `${newFeatures.length} of ${landParcelsData.features.length}`;

            // Also update checkboxes to match
            const checkbox = document.getElementById(`parcel-${parcelId}`);
            if (checkbox) {
              checkbox.checked = existingIndex === -1; // Check if we just added it
            }
          }

          // Only show popup if the parcel was just selected (not deselected)
          if (wasJustSelected) {
            // Build combined popup HTML
            let popupHTML = `<h3 class="govuk-heading-s govuk-!-margin-bottom-2">${parcelProps.SHEET_ID} ${parcelProps.PARCEL_ID}</h3>`;
            popupHTML += `<p class="govuk-body-s govuk-!-margin-bottom-0"><strong>Area</strong></p>`;
            popupHTML += `<p class="govuk-body-s govuk-!-margin-bottom-1">${parseFloat(parcelProps.AREA_HA).toFixed(4)} ha</p>`;

            // Add land cover info if present (regardless of layer visibility)
            if (landCoverFeatures.length > 0) {
              // Get unique land cover descriptions (remove duplicates)
              const landCoverDescriptions = [...new Set(landCoverFeatures.map(f => f.properties.DESCRIPTION || 'N/A'))];
              popupHTML += `<p class="govuk-body-s govuk-!-margin-bottom-0"><strong>Land cover</strong></p>`;
              popupHTML += `<p class="govuk-body-s govuk-!-margin-bottom-1">${landCoverDescriptions.join(', ')}</p>`;
            }

            // Add hedgerow info if present (regardless of layer visibility)
            if (hedgeFeatures.length > 0) {
              // Calculate total hedgerow length for this parcel
              const totalLength = hedgeFeatures.reduce((sum, f) =>
                sum + parseFloat(f.properties.LENGTH || 0), 0
              );
              popupHTML += `<p class="govuk-body-s govuk-!-margin-bottom-0"><strong>Hedgerow</strong></p>`;
              popupHTML += `<p class="govuk-body-s govuk-!-margin-bottom-1">${totalLength.toFixed(2)} m</p>`;
            }

            // Show the combined popup
            new maplibregl.Popup()
              .setLngLat(e.lngLat)
              .setHTML(popupHTML)
              .addTo(map);
          }
        };
      }

      // Remove any existing handlers first
      map.off('click', map._unifiedClickHandler);

      // Attach unified handler to the map itself (not specific layers)
      map.on('click', map._unifiedClickHandler);


      // Change cursor on hover
      map.on('mouseenter', 'parcels-fill', () => {
        map.getCanvas().style.cursor = 'pointer';
      });

      map.on('mouseleave', 'parcels-fill', () => {
        map.getCanvas().style.cursor = '';
      });
    }

    // Add land covers to map
    function addLandCoversToMap(data) {
    if (!data || !data.features || data.features.length === 0) {
        console.log('No land cover features found');
        return;
    }

    // Add source for land covers
    map.addSource('land-covers', {
        type: 'geojson',
        data: data
    });

    // Land cover color mapping using GOV.UK Design System colors
    const landCoverColors = {
        'Permanent Grassland': '#00703c',         // GOV.UK green (dark)
        'Arable Land': '#d4351c',                 // GOV.UK red
        'Temporary Grassland': '#85994b',         // GOV.UK light green/olive
        'Woodland': '#005a30',                    // GOV.UK very dark green
        'Scrub - Ungrazeable': '#f47738',        // GOV.UK orange
        'Notional - Scrub': '#fd0',               // GOV.UK yellow
        'Track - Natural Surface': '#b58840',     // GOV.UK brown
        'Metalled track': '#505a5f',              // GOV.UK dark grey
        'Residential Gardens': '#912b88',         // GOV.UK purple
        'Hard Standings': '#626a6e',              // GOV.UK mid-dark grey
        'Farm Building': '#b1b4b6',               // GOV.UK mid grey
        'Permanent Crops': '#4c2c92',             // GOV.UK dark purple
        'Fallow': '#f3f2f1',                      // GOV.UK light grey
        'Fallow Land': '#f3f2f1',                 // GOV.UK light grey
        'default': '#1d70b8'                      // GOV.UK blue for any unknown types
    };

    // Build color expression for MapLibre
    const colorExpression = ['match', ['get', 'DESCRIPTION']];
    Object.entries(landCoverColors).forEach(([type, color]) => {
        if (type !== 'default') {
            colorExpression.push(type, color);
        }
    });
    colorExpression.push(landCoverColors['default']); // fallback color

    // Add fill layer for land covers with dynamic colors
    map.addLayer({
        id: 'land-covers-fill',
        type: 'fill',
        source: 'land-covers',
        paint: {
            'fill-color': colorExpression,
            'fill-opacity': 0.6
        },
        layout: {
            'visibility': 'none' // Hidden by default
        }
    });

    // Add outline layer for land covers
    map.addLayer({
        id: 'land-covers-outline',
        type: 'line',
        source: 'land-covers',
        paint: {
            'line-color': '#0b0c0c', // Black outline
            'line-width': 1.5
        },
        layout: {
            'visibility': 'none' // Hidden by default
        }
    });

    // Cursor change handlers for land covers
    map.on('mouseenter', 'land-covers-fill', () => {
        map.getCanvas().style.cursor = 'pointer';
    });

    map.on('mouseleave', 'land-covers-fill', () => {
        map.getCanvas().style.cursor = '';
    });
    }


    // Function to populate hedgerows summary statistics
    function populateHedgerowsSummary(data) {
      const summaryContainer = document.getElementById('hedgerows-summary');
      if (!summaryContainer) return;

      if (!data || !data.features || data.features.length === 0) {
        summaryContainer.innerHTML = '<p class="govuk-body-s">No hedgerow data available.</p>';
        return;
      }

      // Calculate statistics
      const totalCount = data.features.length;
      let maxLength = 0;
      let minLength = Infinity;

      data.features.forEach(feature => {
        const length = parseFloat(feature.properties.LENGTH || 0);
        if (length > maxLength) {
          maxLength = length;
        }
        if (length < minLength) {
          minLength = length;
        }
      });

      // Build summary HTML
      const summaryHTML = `
        <p class="govuk-body-s govuk-!-margin-bottom-1">Total ${totalCount}</p>
        <p class="govuk-body-s govuk-!-margin-bottom-1">Longest ${maxLength.toFixed(2)}m</p>
        <p class="govuk-body-s govuk-!-margin-bottom-0">Shortest ${minLength.toFixed(2)}m</p>
      `;

      summaryContainer.innerHTML = summaryHTML;
    }

    // Add hedge control to map
    function addHedgeControlToMap(data) {
      if (!data || !data.features || data.features.length === 0) {
        console.log('No hedge control features found');
        return;
      }

      // Populate summary statistics
      populateHedgerowsSummary(data);

      // Add source for hedge control
      map.addSource('hedge-control', {
        type: 'geojson',
        data: data
      });

      // Add line layer for hedges
      map.addLayer({
        id: 'hedge-control-line',
        type: 'line',
        source: 'hedge-control',
        paint: {
          'line-color': '#912b88', // GOV.UK purple
          'line-width': 3
        },
        layout: {
          'visibility': 'none' // Hidden by default
        }
      });

      // Cursor change handlers for hedgerows
      map.on('mouseenter', 'hedge-control-line', () => {
        map.getCanvas().style.cursor = 'pointer';
      });

      map.on('mouseleave', 'hedge-control-line', () => {
        map.getCanvas().style.cursor = '';
      });
    }

    // Clear highlights when clicking on the map background (not on a parcel)
    map.on('click', (e) => {
      const features = map.queryRenderedFeatures(e.point, {
        layers: ['parcels-fill']
      });

      const selectedValue = document.querySelector('input[name="changedName"]:checked')?.value;

      // If no parcel was clicked and we're in "whole holding" mode, clear everything
      if (features.length === 0 && selectedValue === 'whole-holding') {
        const selectedSource = map.getSource('selected-parcels');
        if (selectedSource) {
          selectedSource.setData({
            type: 'FeatureCollection',
            features: []
          });
        }
      }

      // In individual parcels mode, clicking background doesn't clear selections
    });

    // Helper function to update "Select all" checkbox state based on visible parcels
    function updateSelectAllCheckboxState() {
      const selectAllCheckbox = document.getElementById('select-all-parcels');
      if (!selectAllCheckbox) return;

      const allCheckboxes = document.querySelectorAll('.parcel-checkbox');
      let visibleCheckboxes = [];
      let visibleCheckedCheckboxes = [];

      allCheckboxes.forEach(cb => {
        const parentWrapper = cb.closest('.parcel-item-wrapper');
        if (parentWrapper && parentWrapper.style.display !== 'none') {
          visibleCheckboxes.push(cb);
          if (cb.checked) {
            visibleCheckedCheckboxes.push(cb);
          }
        }
      });

      if (visibleCheckboxes.length === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
      } else {
        selectAllCheckbox.checked = visibleCheckboxes.length === visibleCheckedCheckboxes.length;
        selectAllCheckbox.indeterminate = visibleCheckedCheckboxes.length > 0 && visibleCheckedCheckboxes.length < visibleCheckboxes.length;
      }

      // Update the parcels selected count to show visible parcels
      const sidebarSelectedCount = document.getElementById('sidebar-selected-count');
      if (sidebarSelectedCount) {
        sidebarSelectedCount.textContent = `${visibleCheckedCheckboxes.length} of ${visibleCheckboxes.length}`;
      }
    }

    // Create parcel checkboxes
    function createParcelCheckboxes(data) {
      if (!data || !data.features || data.features.length === 0) {
        document.getElementById('parcels-list').innerHTML =
          '<p class="govuk-body-s">No parcels found for this SBI.</p>';
        return;
      }

      const parcels = data.features.map(f => ({
        id: `${f.properties.SHEET_ID}${f.properties.PARCEL_ID}`,
        sheetId: f.properties.SHEET_ID,
        parcelId: f.properties.PARCEL_ID,
        area: f.properties.AREA_HA,
        feature: f
      }));

      // Sort parcels by ID
      parcels.sort((a, b) => a.id.localeCompare(b.id));

      // Calculate totals and update sidebar elements
      const totalArea = parcels.reduce((sum, p) => sum + parseFloat(p.area || 0), 0);
      document.getElementById('sidebar-total-area').textContent = totalArea.toFixed(4);
      document.getElementById('sidebar-total-parcels').textContent = parcels.length;
      document.getElementById('sidebar-selected-count').textContent = `0 of ${parcels.length}`;

      // Create bordered parcels list with indentation
      let checkboxesHTML = '<div class="govuk-checkboxes govuk-checkboxes--small parcels-bordered-list" data-module="govuk-checkboxes">';

      parcels.forEach(parcel => {
        // Get land covers for this parcel
        let landCoverInfo = '';
        if (landCoversData && landCoversData.features) {
          const parcelLandCovers = landCoversData.features.filter(lc =>
            lc.properties.SHEET_ID === parcel.sheetId &&
            lc.properties.PARCEL_ID === parcel.parcelId
          );

          if (parcelLandCovers.length > 0) {
            // Get unique land cover types
            const uniqueLandCovers = [...new Set(parcelLandCovers.map(lc => lc.properties.DESCRIPTION))];
            landCoverInfo = uniqueLandCovers.join(', ');
          }
        }

        // Get hedgerows for this parcel
        let hedgerowInfo = '';
        if (hedgeControlData && hedgeControlData.features) {
          const parcelHedgerows = hedgeControlData.features.filter(h =>
            h.properties.REF_PARCEL_SHEET_ID === parcel.sheetId &&
            h.properties.REF_PARCEL_PARCEL_ID === parcel.parcelId
          );

          if (parcelHedgerows.length > 0) {
            const totalLength = parcelHedgerows.reduce((sum, h) => sum + parseFloat(h.properties.LENGTH || 0), 0);
            hedgerowInfo = `${parcelHedgerows.length} hedgerow${parcelHedgerows.length !== 1 ? 's' : ''} (${totalLength.toFixed(2)}m)`;
          }
        }

        // Build hint content
        let hintContent = `${parseFloat(parcel.area).toFixed(4)} (ha)`;
        if (landCoverInfo) {
          hintContent += `<br>${landCoverInfo}`;
        }
        if (hedgerowInfo) {
          hintContent += `<br>${hedgerowInfo}`;
        }

        checkboxesHTML += `
          <div class="parcel-item-wrapper">
            <div class="govuk-checkboxes__item">
              <input class="govuk-checkboxes__input parcel-checkbox"
                     id="parcel-${parcel.id}"
                     name="landParcels"
                     type="checkbox"
                     value="${parcel.id}"
                     data-area="${parcel.area}">
              <label class="govuk-label govuk-checkboxes__label" for="parcel-${parcel.id}">
                ${parcel.sheetId} ${parcel.parcelId}
              </label>
              <div class="govuk-hint govuk-checkboxes__hint">
                ${hintContent}
              </div>
            </div>
          </div>
        `;
      });

      checkboxesHTML += '</div>';

      document.getElementById('parcels-list').innerHTML = checkboxesHTML;

      // Add event listener to "Select all" checkbox
      const selectAllCheckbox = document.getElementById('select-all-parcels');
      if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', function() {
          // Only select visible (filtered) parcels
          const parcelCheckboxes = document.querySelectorAll('.parcel-checkbox');
          parcelCheckboxes.forEach(checkbox => {
            // Check if the parent wrapper is visible
            const parentWrapper = checkbox.closest('.parcel-item-wrapper');
            if (parentWrapper && parentWrapper.style.display !== 'none') {
              checkbox.checked = this.checked;
            }
          });
          updateSelectedParcels();
        });
      }

      // Add event listeners to individual parcel checkboxes
      document.querySelectorAll('.parcel-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          updateSelectedParcels();

          // Update "Select all" checkbox state based on visible parcels only
          updateSelectAllCheckboxState();
        });
      });

      // Make the whole parcel item clickable (only bordered parcels)
      document.querySelectorAll('.parcel-item-wrapper').forEach(wrapper => {
        wrapper.addEventListener('click', function(e) {
          // Don't trigger if clicking on the checkbox itself or label (they handle it naturally)
          if (e.target.type === 'checkbox' || e.target.tagName === 'LABEL') {
            return;
          }

          // Find the checkbox within this wrapper and toggle it
          const checkbox = this.querySelector('.parcel-checkbox');
          if (checkbox) {
            checkbox.checked = !checkbox.checked;
            // Trigger the change event to update the map
            checkbox.dispatchEvent(new Event('change'));
          }
        });
      });
    }

    // Update selected parcels on map
    function updateSelectedParcels() {
      const selectedCheckboxes = document.querySelectorAll('.parcel-checkbox:checked');
      const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.value);

      // Filter features for selected parcels
      const selectedFeatures = landParcelsData.features.filter(f => {
        const id = `${f.properties.SHEET_ID}${f.properties.PARCEL_ID}`;
        return selectedIds.includes(id);
      });

      // Update selected parcels source
      const selectedSource = map.getSource('selected-parcels');
      if (selectedSource) {
        selectedSource.setData({
          type: 'FeatureCollection',
          features: selectedFeatures
        });

        // Calculate selected area
        const selectedArea = Array.from(selectedCheckboxes)
          .reduce((sum, cb) => sum + parseFloat(cb.dataset.area || 0), 0);

        // Update sidebar elements
        document.getElementById('sidebar-selected-area').textContent = selectedArea.toFixed(4);
        document.getElementById('sidebar-selected-count').textContent =
          `${selectedCheckboxes.length} of ${landParcelsData.features.length}`;
      }
    }

    // Setup accordion-based view controls
    function setupAccordionControls() {
      // Land cover color mapping using GOV.UK Design System colors - high contrast
      // Based on actual RPA API land cover descriptions
      const landCoverColors = {
        'Permanent Grassland': '#00703c',         // GOV.UK green (dark)
        'Arable Land': '#d4351c',                 // GOV.UK red
        'Temporary Grassland': '#85994b',         // GOV.UK light green/olive
        'Woodland': '#005a30',                    // GOV.UK very dark green
        'Scrub - Ungrazeable': '#f47738',        // GOV.UK orange
        'Notional - Scrub': '#fd0',               // GOV.UK yellow
        'Track - Natural Surface': '#b58840',     // GOV.UK brown
        'Metalled track': '#505a5f',              // GOV.UK dark grey
        'Residential Gardens': '#912b88',         // GOV.UK purple
        'Hard Standings': '#626a6e',              // GOV.UK mid-dark grey
        'Farm Building': '#b1b4b6',               // GOV.UK mid grey
        'Permanent Crops': '#4c2c92',             // GOV.UK dark purple
        'Fallow': '#f3f2f1',                      // GOV.UK light grey
        'Fallow Land': '#f3f2f1',                 // GOV.UK light grey
        'default': '#1d70b8'                      // GOV.UK blue for any unknown types
      };

      // Function to populate individual land cover checkboxes
      function populateLandCoverCheckboxes() {
        const container = document.getElementById('land-covers-list');
        if (!container || landCoverTypes.length === 0) return;

        // Count occurrences of each land cover type
        const landCoverCounts = {};
        if (landCoversData && landCoversData.features) {
          landCoversData.features.forEach(feature => {
            const type = feature.properties.DESCRIPTION;
            landCoverCounts[type] = (landCoverCounts[type] || 0) + 1;
          });
        }

        const checkboxesHTML = landCoverTypes.map((type, index) => {
          const color = landCoverColors[type] || landCoverColors['default'];
          const sanitizedValue = type.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
          const count = landCoverCounts[type] || 0;
          return `
            <div class="govuk-checkboxes__item">
              <input class="govuk-checkboxes__input land-cover-checkbox"
                     id="land-cover-${sanitizedValue}"
                     name="land-cover"
                     type="checkbox"
                     value="${type}">
              <label class="govuk-label govuk-checkboxes__label" for="land-cover-${sanitizedValue}">
                ${type} (${count})
              </label>
            </div>
          `;
        }).join('');

        container.innerHTML = `
          <div class="govuk-checkboxes govuk-checkboxes--small">
            ${checkboxesHTML}
          </div>
        `;

        // Add event listeners to individual land cover checkboxes
        document.querySelectorAll('.land-cover-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', function() {
            const landCoverType = this.value;

            if (this.checked) {
              activeLandCovers.add(landCoverType);
            } else {
              activeLandCovers.delete(landCoverType);
            }

            // Update the map filter
            updateLandCoverFilter();

            // Update legend
            updateLegendForLandCovers();

            // Filter the parcel list based on selected land covers
            filterParcelsByLandCover();

            // Update the land covers selected count
            updateLandCoversSelectedCount();
          });
        });
      }

      // Function to update land covers selected count in accordion summary
      function updateLandCoversSelectedCount() {
        const countElement = document.getElementById('land-covers-selected-count');
        if (countElement) {
          countElement.textContent = activeLandCovers.size;
        }
      }

      // Function to update land cover filter based on selected types
      function updateLandCoverFilter() {
        if (!map.getLayer('land-covers-fill')) return;

        if (activeLandCovers.size === 0) {
          // If no land covers selected, hide the layers
          map.setLayoutProperty('land-covers-fill', 'visibility', 'none');
          map.setLayoutProperty('land-covers-outline', 'visibility', 'none');
        } else {
          // Show layers and apply filter
          map.setLayoutProperty('land-covers-fill', 'visibility', 'visible');
          map.setLayoutProperty('land-covers-outline', 'visibility', 'visible');

          // Create filter expression: show only selected land cover types
          const filter = ['in', ['get', 'DESCRIPTION'], ['literal', Array.from(activeLandCovers)]];
          map.setFilter('land-covers-fill', filter);
          map.setFilter('land-covers-outline', filter);
        }
      }

      // Function to filter parcel list based on selected land covers
      function filterParcelsByLandCover() {
        const hedgerowsCheckbox = document.getElementById('hedgerows-checkbox');
        const parcelWrappers = document.querySelectorAll('#parcels-list .parcel-item-wrapper');

        // Check if hedgerows filter is active
        const hedgerowsActive = hedgerowsCheckbox && hedgerowsCheckbox.checked;

        // Get parcels that have hedgerows (if filter is active)
        let hedgerowValidParcelIds = null;
        if (hedgerowsActive && hedgeControlData && hedgeControlData.features) {
          hedgerowValidParcelIds = new Set();
          hedgeControlData.features.forEach(hedgeFeature => {
            const parcelId = `${hedgeFeature.properties.REF_PARCEL_SHEET_ID}${hedgeFeature.properties.REF_PARCEL_PARCEL_ID}`;
            hedgerowValidParcelIds.add(parcelId);
          });
        }

        // If no land covers are selected
        if (activeLandCovers.size === 0) {
          parcelWrappers.forEach(wrapper => {
            const checkbox = wrapper.querySelector('.parcel-checkbox');
            if (!checkbox) return;

            const parcelId = checkbox.value;
            const label = wrapper.querySelector('.govuk-checkboxes__label');
            const labelText = label ? label.textContent.toLowerCase() : '';
            const filterInput = document.getElementById('parcel-filter');
            const filterValue = filterInput ? filterInput.value.toLowerCase() : '';

            // Check hedgerows filter
            let matchesHedgerows = hedgerowValidParcelIds === null || hedgerowValidParcelIds.has(parcelId);

            // Check text filter
            let matchesTextFilter = filterValue === '' || labelText.includes(filterValue);

            if (matchesHedgerows && matchesTextFilter) {
              wrapper.style.display = '';
            } else {
              wrapper.style.display = 'none';
            }
          });
          // Update "Select all" checkbox state after filtering
          updateSelectAllCheckboxState();
          return;
        }

        // Get parcels that have the selected land cover types
        const validParcelIds = new Set();

        if (landCoversData && landCoversData.features) {
          landCoversData.features.forEach(landCoverFeature => {
            const landCoverType = landCoverFeature.properties.DESCRIPTION;

            // If this land cover is one of the selected types
            if (activeLandCovers.has(landCoverType)) {
              const parcelId = `${landCoverFeature.properties.SHEET_ID}${landCoverFeature.properties.PARCEL_ID}`;
              validParcelIds.add(parcelId);
            }
          });
        }

        // Show/hide parcel checkboxes based on all active filters
        parcelWrappers.forEach(wrapper => {
          const checkbox = wrapper.querySelector('.parcel-checkbox');
          if (!checkbox) return;

          const parcelId = checkbox.value;
          const label = wrapper.querySelector('.govuk-checkboxes__label');
          const labelText = label ? label.textContent.toLowerCase() : '';
          const filterInput = document.getElementById('parcel-filter');
          const filterValue = filterInput ? filterInput.value.toLowerCase() : '';

          // Check land cover filter
          let matchesLandCover = validParcelIds.has(parcelId);

          // Check hedgerows filter
          let matchesHedgerows = hedgerowValidParcelIds === null || hedgerowValidParcelIds.has(parcelId);

          // Check text filter
          let matchesTextFilter = filterValue === '' || labelText.includes(filterValue);

          if (matchesLandCover && matchesHedgerows && matchesTextFilter) {
            wrapper.style.display = '';
          } else {
            wrapper.style.display = 'none';
          }
        });

        // Update "Select all" checkbox state after filtering
        updateSelectAllCheckboxState();
      }

      // Function to filter parcel list based on hedgerows
      function filterParcelsByHedgerows() {
        const hedgerowsCheckbox = document.getElementById('hedgerows-checkbox');
        const parcelWrappers = document.querySelectorAll('#parcels-list .parcel-item-wrapper');

        // If hedgerows checkbox is not checked, show parcels based on other filters
        if (!hedgerowsCheckbox || !hedgerowsCheckbox.checked) {
          // Re-apply existing filters (land cover and text)
          filterParcelsByLandCover();
          return;
        }

        // Get parcels that have hedgerows
        const validParcelIds = new Set();

        if (hedgeControlData && hedgeControlData.features) {
          hedgeControlData.features.forEach(hedgeFeature => {
            const parcelId = `${hedgeFeature.properties.REF_PARCEL_SHEET_ID}${hedgeFeature.properties.REF_PARCEL_PARCEL_ID}`;
            validParcelIds.add(parcelId);
          });
        }

        // Also need to get parcels that match land cover filter (if active)
        let landCoverValidParcelIds = null;
        if (activeLandCovers.size > 0 && landCoversData && landCoversData.features) {
          landCoverValidParcelIds = new Set();
          landCoversData.features.forEach(landCoverFeature => {
            const landCoverType = landCoverFeature.properties.DESCRIPTION;
            if (activeLandCovers.has(landCoverType)) {
              const parcelId = `${landCoverFeature.properties.SHEET_ID}${landCoverFeature.properties.PARCEL_ID}`;
              landCoverValidParcelIds.add(parcelId);
            }
          });
        }

        // Show/hide parcel checkboxes based on filters
        parcelWrappers.forEach(wrapper => {
          const checkbox = wrapper.querySelector('.parcel-checkbox');
          if (!checkbox) return;

          const parcelId = checkbox.value;
          const label = wrapper.querySelector('.govuk-checkboxes__label');
          const labelText = label ? label.textContent.toLowerCase() : '';
          const filterInput = document.getElementById('parcel-filter');
          const filterValue = filterInput ? filterInput.value.toLowerCase() : '';

          // Parcel must have hedgerows
          let hasHedgerows = validParcelIds.has(parcelId);

          // If land cover filter is active, parcel must also match land cover
          let matchesLandCover = landCoverValidParcelIds === null || landCoverValidParcelIds.has(parcelId);

          // Must also pass text filter
          let matchesTextFilter = filterValue === '' || labelText.includes(filterValue);

          if (hasHedgerows && matchesLandCover && matchesTextFilter) {
            wrapper.style.display = '';
          } else {
            wrapper.style.display = 'none';
          }
        });

        // Update "Select all" checkbox state after filtering
        updateSelectAllCheckboxState();
      }

      // Function to get predominant land cover for a parcel (kept for reference but not actively used)
      function getParcelLandCover(parcelId) {
        if (!landCoversData || !landCoversData.features) return null;

        // Find land covers that intersect with this parcel
        const parcelFeature = landParcelsData.features.find(f =>
          `${f.properties.SHEET_ID}${f.properties.PARCEL_ID}` === parcelId
        );

        if (!parcelFeature) return null;

        // Find the first land cover feature that matches this parcel
        const landCover = landCoversData.features.find(lc =>
          lc.properties.SHEET_ID === parcelFeature.properties.SHEET_ID &&
          lc.properties.PARCEL_ID === parcelFeature.properties.PARCEL_ID
        );

        return landCover ? landCover.properties.DESCRIPTION : null;
      }

      // Function to toggle legend visibility
      function toggleLegend(show) {
        const legendOverlay = document.getElementById('legend-overlay');
        if (legendOverlay) {
          // Always show the legend overlay (toggle button), but update content
          legendOverlay.style.display = 'block';

          // Update legend content based on whether land covers are enabled
          updateLegendContent(show);
        }
      }

      // Function to populate legend with actual land cover types
      function updateLegendContent(landCoversEnabled) {
        const legendContent = document.getElementById('legend-content');
        if (!legendContent) return;

        if (!landCoversEnabled || !landCoversData || activeLandCovers.size === 0) {
          // Show "no features" message
          legendContent.innerHTML = '<p class="govuk-body">No features to display</p>';
          return;
        }

        // Build legend HTML for selected land covers only
        let html = '<div class="map-legend-items">';

        // Sort selected land covers by name
        const sortedLandCovers = Array.from(activeLandCovers).sort();

        sortedLandCovers.forEach(landUse => {
          const color = landCoverColors[landUse] || landCoverColors['default'];
          html += `
            <div class="map-legend-item">
              <span class="map-legend-color" style="background-color: ${color};"></span>
              <span class="map-legend-label">${landUse}</span>
            </div>
          `;
        });

        html += '</div>';
        html += '<p class="govuk-body-s govuk-!-margin-top-2 govuk-!-margin-bottom-0">Individual land covers are displayed with distinct colours within parcels.</p>';
        legendContent.innerHTML = html;
      }

      // Legend toggle functionality
      function showLegend() {
        const legendContainer = document.getElementById('legend-container');
        const legendToggle = document.getElementById('legend-toggle');
        if (legendContainer && legendToggle) {
          legendContainer.style.display = 'block';
          legendToggle.style.display = 'none';
        }
      }

      function hideLegend() {
        const legendContainer = document.getElementById('legend-container');
        const legendToggle = document.getElementById('legend-toggle');
        if (legendContainer && legendToggle) {
          legendContainer.style.display = 'none';
          legendToggle.style.display = 'block';
        }
      }

      const legendToggle = document.getElementById('legend-toggle');
      const legendClose = document.getElementById('legend-close');

      if (legendToggle) {
        legendToggle.addEventListener('click', showLegend);
      }

      if (legendClose) {
        legendClose.addEventListener('click', hideLegend);
      }

      // Populate land covers checkboxes when accordion section is first opened
      // The GOV.UK accordion generates buttons with specific aria-controls
      // For our accordion with id "accordion-land-data", the second item (Land covers) will be "accordion-land-data-content-2"
      const landCoversAccordionButton = document.querySelector('.govuk-accordion__section-button[aria-controls="accordion-land-data-content-2"]');
      if (landCoversAccordionButton) {
        landCoversAccordionButton.addEventListener('click', function() {
          // Small delay to allow accordion to open
          setTimeout(() => {
            const landCoversList = document.getElementById('land-covers-list');
            if (landCoversList && landCoversList.querySelector('.govuk-checkboxes') === null) {
              populateLandCoverCheckboxes();
            }
          }, 150);
        });
      }

      // Also populate immediately if the section is already expanded (fallback)
      setTimeout(() => {
        const landCoversList = document.getElementById('land-covers-list');
        if (landCoversList && landCoversList.offsetParent !== null && landCoversList.querySelector('.govuk-checkboxes') === null) {
          populateLandCoverCheckboxes();
        }
      }, 500);

      // Handle hedgerows checkbox in hedgerows accordion section
      const hedgerowsCheckbox = document.getElementById('hedgerows-checkbox');
      if (hedgerowsCheckbox) {
        hedgerowsCheckbox.addEventListener('change', function() {
          const legendOverlay = document.getElementById('legend-overlay');

          // Show/hide hedgerows on map
          if (map.getLayer('hedge-control-line')) {
            map.setLayoutProperty('hedge-control-line', 'visibility',
              this.checked ? 'visible' : 'none');
          }

          // Show/hide legend overlay
          if (legendOverlay) {
            legendOverlay.style.display = this.checked ? 'block' : 'none';
          }

          // Filter the parcel list based on hedgerows
          filterParcelsByHedgerows();
        });
      }

      // Function to update legend based on active land covers
      function updateLegendForLandCovers() {
        const legendContent = document.getElementById('legend-content');
        const legendOverlay = document.getElementById('legend-overlay');
        if (!legendContent) return;

        let html = '';
        let hasContent = false;

        // Add land covers to legend if any are selected
        if (activeLandCovers.size > 0) {
          hasContent = true;
          html += '<div class="map-legend-items">';
          const sortedLandCovers = Array.from(activeLandCovers).sort();
          sortedLandCovers.forEach(landUse => {
            const color = landCoverColors[landUse] || landCoverColors['default'];
            html += `
              <div class="map-legend-item">
                <span class="map-legend-color" style="background-color: ${color};"></span>
                <span class="map-legend-label">${landUse}</span>
              </div>
            `;
          });
          html += '</div>';
        }

        if (!hasContent) {
          legendContent.innerHTML = '<p class="govuk-body">No features to display</p>';
          // Hide legend overlay if nothing to show
          if (legendOverlay) {
            legendOverlay.style.display = 'none';
          }
        } else {
          legendContent.innerHTML = html;
          // Show legend overlay if we have content
          if (legendOverlay) {
            legendOverlay.style.display = 'block';
          }
        }
      }
    }

    // Debounce helper function
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Location search functionality
    const searchForm = document.getElementById('location-search-form');
    const searchInput = document.getElementById('location-search');
    const searchResults = document.getElementById('search-results');
    const searchResultsList = document.getElementById('search-results-list');

    function simplifyDisplayName(displayName) {
      let parts = displayName.split(',').map(part => part.trim());
      const unwantedTerms = ['England', 'United Kingdom', 'UK'];

      parts = parts.filter((part, index) => {
        if (unwantedTerms.some(term => part === term)) {
          return false;
        }
        if (index === parts.length - 2 && parts[parts.length - 1] === 'England') {
          return false;
        }
        if (index === parts.length - 3 && parts[parts.length - 1] === 'United Kingdom') {
          return false;
        }
        return true;
      });

      return parts.slice(0, 3).join(', ');
    }

    // Search parcels by ID
    function searchParcels(query) {
      if (!landParcelsData || !landParcelsData.features) {
        return [];
      }

      const searchTerm = query.toLowerCase().replace(/\s+/g, '');

      return landParcelsData.features.filter(feature => {
        const parcelId = `${feature.properties.SHEET_ID}${feature.properties.PARCEL_ID}`.toLowerCase();
        const parcelIdWithSpace = `${feature.properties.SHEET_ID} ${feature.properties.PARCEL_ID}`.toLowerCase();
        return parcelId.includes(searchTerm) || parcelIdWithSpace.includes(query.toLowerCase());
      }).map(feature => ({
        type: 'parcel',
        feature: feature,
        displayName: `${feature.properties.SHEET_ID} ${feature.properties.PARCEL_ID}`,
        area: feature.properties.AREA_HA
      }));
    }

    async function searchLocation(query) {
      if (query.length < 2) {
        searchResults.style.display = 'none';
        return;
      }

      // First, search for matching parcels
      const parcelResults = searchParcels(query);

      // Then search for locations
      let locationResults = [];
      if (query.length >= 3) {
        try {
          const response = await fetch(
            `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=3&countrycodes=gb`
          );
          locationResults = await response.json();
          locationResults = locationResults.map(result => ({
            type: 'location',
            data: result,
            displayName: simplifyDisplayName(result.display_name)
          }));
        } catch (error) {
          console.error('Search error:', error);
        }
      }

      // Combine results (parcels first)
      const allResults = [...parcelResults, ...locationResults];

      if (allResults.length > 0) {
        displaySearchResults(allResults);
      } else {
        searchResults.style.display = 'none';
      }
    }

    function displaySearchResults(results) {
      searchResultsList.innerHTML = '';

      results.forEach(result => {
        const li = document.createElement('li');
        li.className = 'map-search-results-item';

        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'map-search-results-button';

        if (result.type === 'parcel') {
          button.innerHTML = `
            <strong>${result.displayName}</strong><br>
            <span style="font-size: 14px; color: #505a5f;">Total area (ha) ${parseFloat(result.area).toFixed(4)}</span>
          `;
          button.addEventListener('click', () => {
            selectParcel(result.feature);
          });
        } else {
          button.textContent = result.displayName;
          button.addEventListener('click', () => {
            selectLocation(result.data);
          });
        }

        li.appendChild(button);
        searchResultsList.appendChild(li);
      });

      searchResults.style.display = 'block';
    }

    function selectParcel(feature) {
      // Calculate bounds of the parcel
      const bounds = new maplibregl.LngLatBounds();

      if (feature.geometry.type === 'Polygon') {
        feature.geometry.coordinates[0].forEach(coord => {
          bounds.extend(coord);
        });
      } else if (feature.geometry.type === 'MultiPolygon') {
        feature.geometry.coordinates.forEach(polygon => {
          polygon[0].forEach(coord => {
            bounds.extend(coord);
          });
        });
      }

      // Fit map to parcel bounds with padding
      map.fitBounds(bounds, {
        padding: 100,
        duration: 2000
      });

      // Update search input
      searchInput.value = `${feature.properties.SHEET_ID} ${feature.properties.PARCEL_ID}`;
      searchResults.style.display = 'none';

      // Highlight the parcel
      const selectedSource = map.getSource('selected-parcels');
      if (selectedSource) {
        selectedSource.setData({
          type: 'FeatureCollection',
          features: [feature]
        });
      }

      // Show popup
      const center = bounds.getCenter();
      new maplibregl.Popup()
        .setLngLat(center)
        .setHTML(`
          <strong>Land parcel</strong><br>
          ${feature.properties.SHEET_ID} ${feature.properties.PARCEL_ID}<br>
          Total area (ha): ${parseFloat(feature.properties.AREA_HA).toFixed(4)}
        `)
        .addTo(map);
    }

    function selectLocation(result) {
      const lat = parseFloat(result.lat);
      const lon = parseFloat(result.lon);

      map.flyTo({
        center: [lon, lat],
        zoom: 15,
        duration: 2000
      });

      if (searchMarker) {
        searchMarker.remove();
      }

      searchMarker = new maplibregl.Marker({
        color: '#1d70b8'
      })
        .setLngLat([lon, lat])
        .addTo(map);

      searchInput.value = simplifyDisplayName(result.display_name);
      searchResults.style.display = 'none';
    }

    searchForm.addEventListener('submit', (e) => {
      e.preventDefault();

      const firstResult = searchResultsList.querySelector('.map-search-results-button');
      if (firstResult && searchResults.style.display !== 'none') {
        firstResult.click();
      }
    });

    const debouncedSearch = debounce((query) => {
      searchLocation(query);
    }, 300);

    searchInput.addEventListener('input', (e) => {
      debouncedSearch(e.target.value.trim());
    });

    document.addEventListener('click', (e) => {
      if (!searchForm.contains(e.target) && !searchResults.contains(e.target)) {
        searchResults.style.display = 'none';
      }
    });

    // Search toggle functionality
    const searchToggle = document.getElementById('search-toggle');
    const searchContainer = document.getElementById('search-container');
    const searchClose = document.getElementById('search-close');
    const filterInput = document.getElementById('parcel-filter');

    function hideSearch() {
      searchContainer.style.display = 'none';
      searchToggle.style.display = 'flex';
      searchToggle.setAttribute('aria-label', 'Show search');
      searchInput.value = '';
      searchResults.style.display = 'none';
    }

    function showSearch() {
      searchContainer.style.display = 'block';
      searchToggle.style.display = 'none';
      searchToggle.setAttribute('aria-label', 'Hide search');
      setTimeout(() => searchInput.focus(), 100);
    }

    if (searchToggle && searchContainer) {
      searchToggle.addEventListener('click', showSearch);
    }

    if (searchClose) {
      searchClose.addEventListener('click', hideSearch);
    }


    function filterParcels() {
      const filterValue = filterInput.value.toLowerCase();
      const parcelWrappers = document.querySelectorAll('#parcels-list .parcel-item-wrapper');
      const hedgerowsCheckbox = document.getElementById('hedgerows-checkbox');

      // Check if hedgerows filter is active
      const hedgerowsActive = hedgerowsCheckbox && hedgerowsCheckbox.checked;

      // Get parcels that have hedgerows (if filter is active)
      let hedgerowValidParcelIds = null;
      if (hedgerowsActive && hedgeControlData && hedgeControlData.features) {
        hedgerowValidParcelIds = new Set();
        hedgeControlData.features.forEach(hedgeFeature => {
          const parcelId = `${hedgeFeature.properties.REF_PARCEL_SHEET_ID}${hedgeFeature.properties.REF_PARCEL_PARCEL_ID}`;
          hedgerowValidParcelIds.add(parcelId);
        });
      }

      // Get parcels that match land cover filter (if active)
      let landCoverValidParcelIds = null;
      if (activeLandCovers.size > 0 && landCoversData && landCoversData.features) {
        landCoverValidParcelIds = new Set();
        landCoversData.features.forEach(landCoverFeature => {
          const landCoverType = landCoverFeature.properties.DESCRIPTION;
          if (activeLandCovers.has(landCoverType)) {
            const parcelId = `${landCoverFeature.properties.SHEET_ID}${landCoverFeature.properties.PARCEL_ID}`;
            landCoverValidParcelIds.add(parcelId);
          }
        });
      }

      // Apply all filters together
      parcelWrappers.forEach(wrapper => {
        const checkbox = wrapper.querySelector('.parcel-checkbox');
        if (!checkbox) return;

        const parcelId = checkbox.value;
        const label = wrapper.querySelector('.govuk-checkboxes__label');
        const labelText = label ? label.textContent.toLowerCase() : '';

        // Check land cover filter
        let matchesLandCover = landCoverValidParcelIds === null || landCoverValidParcelIds.has(parcelId);

        // Check hedgerows filter
        let matchesHedgerows = hedgerowValidParcelIds === null || hedgerowValidParcelIds.has(parcelId);

        // Check text filter
        let matchesTextFilter = labelText.includes(filterValue);

        if (matchesLandCover && matchesHedgerows && matchesTextFilter) {
          wrapper.style.display = '';
        } else {
          wrapper.style.display = 'none';
        }
      });

      // Update "Select all" checkbox state after filtering
      updateSelectAllCheckboxState();
    }

    // Debounced filter function
    if (filterInput) {
      const debouncedFilter = debounce(filterParcels, 150);
      filterInput.addEventListener('input', debouncedFilter);
    }

    // Load parcels when map is ready - THIS MUST BE LAST
    map.on('load', function() {
    // Create and add style toggle button with icon
    const styleToggle = document.createElement('button');
    styleToggle.id = 'style-toggle';
    styleToggle.className = 'map-style-toggle';
    styleToggle.setAttribute('aria-label', 'Switch to satellite view');
    styleToggle.setAttribute('title', 'Switch to satellite view'); // Tooltip on hover

    // Add icon as background image
    styleToggle.innerHTML = '<img src="/public/images/map.svg" alt="" aria-hidden="true">';

    // Add to map container
    document.getElementById('map').appendChild(styleToggle);

      // Create custom zoom controls
      const zoomControls = document.createElement('div');
      zoomControls.className = 'custom-zoom-controls';

      const zoomIn = document.createElement('button');
      zoomIn.className = 'custom-zoom-button';
      zoomIn.setAttribute('aria-label', 'Zoom in');
      zoomIn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
      zoomIn.addEventListener('click', () => map.zoomIn());

      const zoomOut = document.createElement('button');
      zoomOut.className = 'custom-zoom-button';
      zoomOut.setAttribute('aria-label', 'Zoom out');
      zoomOut.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
      zoomOut.addEventListener('click', () => map.zoomOut());

      zoomControls.appendChild(zoomIn);
      zoomControls.appendChild(zoomOut);
      document.getElementById('map').appendChild(zoomControls);

      let currentStyle = 'streets';
      styleToggle.addEventListener('click', () => {
        // Store current view before switching
        const currentCenter = map.getCenter();
        const currentZoom = map.getZoom();
        const currentBearing = map.getBearing();
        const currentPitch = map.getPitch();

        if (currentStyle === 'streets') {
          // Switch to satellite
          map.setStyle({
            'version': 8,
            'sources': {
              'satellite-tiles': {
                'type': 'raster',
                'tiles': [
                  'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
                ],
                'tileSize': 256,
                'attribution': '© Esri, Maxar, Earthstar Geographics'
              }
            },
            'layers': [
              {
                'id': 'satellite',
                'type': 'raster',
                'source': 'satellite-tiles',
                'minzoom': 0,
                'maxzoom': 22
              }
            ]
          });
          currentStyle = 'satellite';
          styleToggle.setAttribute('aria-label', 'Switch to map view');
          styleToggle.setAttribute('title', 'Switch to map view');
        } else {
          // Switch to streets
          map.setStyle({
            'version': 8,
            'sources': {
              'raster-tiles': {
                'type': 'raster',
                'tiles': [
                  'https://tile.openstreetmap.org/{z}/{x}/{y}.png'
                ],
                'tileSize': 256,
                'attribution': '© OpenStreetMap contributors'
              }
            },
            'layers': [
              {
                'id': 'simple-tiles',
                'type': 'raster',
                'source': 'raster-tiles',
                'minzoom': 0,
                'maxzoom': 22
              }
            ]
          });
          currentStyle = 'streets';
          styleToggle.setAttribute('aria-label', 'Switch to satellite view');
          styleToggle.setAttribute('title', 'Switch to satellite view');
        }

        // Remove focus after click
        styleToggle.blur();

        // Re-add your data layers after style change
        map.once('styledata', () => {
          // Restore the view position
          map.jumpTo({
            center: currentCenter,
            zoom: currentZoom,
            bearing: currentBearing,
            pitch: currentPitch
          });

          // setStyle() already removes all layers and sources, so we just re-add
          if (landParcelsData) {
            addParcelsToMap(landParcelsData);
          }
          if (landCoversData) {
            addLandCoversToMap(landCoversData);
          }
          if (hedgeControlData) {
            addHedgeControlToMap(hedgeControlData);
          }

          // Re-setup controls
          setupAccordionControls();

          // Restore the current selection state for parcels
          updateSelectedParcels();

          // Restore data layer visibility based on checkboxes
          const landCoversCheckbox = document.querySelector('input[name="dataLayers"][value="land-covers"]');
          const hedgerowsCheckbox = document.querySelector('input[name="dataLayers"][value="hedgerows"]');

          if (landCoversCheckbox && landCoversCheckbox.checked && activeLandCovers.size > 0) {
            // Restore land cover filter
            updateLandCoverFilter();
          }

          if (hedgerowsCheckbox && hedgerowsCheckbox.checked) {
            // Restore hedgerows visibility
            if (map.getLayer('hedge-control-line')) {
              map.setLayoutProperty('hedge-control-line', 'visibility', 'visible');
            }
          }
        });
      });

      // OPTIMIZED: Fetch all data in parallel with Promise.all
      (async () => {
        const [parcelsData, coversData, hedgesData] = await Promise.all([
          fetchLandParcels(),
          fetchLandCovers(),
          fetchHedgeControl()
        ]);

        if (parcelsData) {
          addParcelsToMap(parcelsData);
          createParcelCheckboxes(parcelsData);
        }

        if (coversData) {
          addLandCoversToMap(coversData);
        }

        if (hedgesData) {
          addHedgeControlToMap(hedgesData);
        }

        // Set up accordion controls
        setupAccordionControls();
      })();
    });
  });
</script>

<style>
  .scrollable-checkbox-container {
    max-height: 325px;
    overflow-y: auto;
    overflow-x: visible;
    margin-left: -15px;
    padding-left: 15px;
    padding-right: 10px;
    margin-bottom: 30px;
  }

  /* Single column layout for parcel checkboxes */
  #parcels-list .govuk-checkboxes {
    display: block;
  }

  /* Single column layout for land cover checkboxes */
  #land-covers-list .govuk-checkboxes {
    display: block; /* Single column */
  }

  /* Make parcel checkboxes display inline in columns */
  .scrollable-checkbox-container .govuk-checkboxes__label {
    font-size: 1rem;
    line-height: 1.25;
  }

  .scrollable-checkbox-container .govuk-checkboxes__hint {
    font-size: 1rem;
    line-height: 1.25;
    padding-right: 0px;
    margin-top: -14px;
  }

  /* Styling for hints in parcels list with multi-line content */
  #parcels-list .govuk-checkboxes__hint {
    margin-bottom: 0;
    line-height: 1.4;
  }

  /* Style for "Select all" checkbox (separate list) */
  #parcels-list > .govuk-checkboxes:first-child .govuk-checkboxes__item {
    border: none;
    padding: 0;
    margin-bottom: 0;
  }

  #parcels-list > .govuk-checkboxes:first-child .govuk-checkboxes__label {
    align-items: center;
    padding-top: 0;
    min-height: 40px;
    display: flex;
  }

  /* Style for parcel wrapper with border and padding */
  .parcel-item-wrapper {
    margin-bottom: 5px;
    border: 1px solid #d4d7db;
    padding: 0px 5px 10px 8px;
    cursor: pointer;
  }

  /* Highlight selected parcels */
  .parcel-item-wrapper:has(input:checked) {
    background-color: #f4f8fb;
  }

  /* Reset styles on the checkbox item inside wrapper */
  .parcel-item-wrapper .govuk-checkboxes__item {
    margin-bottom: 0;
  }

  /* Align label to top */
  .parcel-item-wrapper .govuk-checkboxes__label {
    align-items: flex-start;
    padding-top: 0;
    min-height: auto;
  }

  .govuk-radios__label {
    font-size: 1rem;
    line-height: 1.25;
  }

  .scrollable-checkbox-container::-webkit-scrollbar {
    width: 8px;
  }

  .scrollable-checkbox-container::-webkit-scrollbar-track {
    background: #f1f1f1;
  }

  .scrollable-checkbox-container::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 0px;
  }

  .scrollable-checkbox-container::-webkit-scrollbar-thumb:hover {
    background: #555;
  }

  /* Map search styles - inline in overlay */
  /* Map search styles - larger input with close button */
  .map-search-form {
    margin-bottom: 0;
  }

  .map-search-wrapper-with-close {
    position: relative;
    margin-bottom: 10px;
  }

  .map-search-input-large {
    font-size: 1rem;
    line-height: 1.25;
    padding: 13px 45px 13px 12px;
    width: 100%;
    min-width: 300px;
    border: 2px solid #0b0c0c;
  }

  .map-search-input-large:focus {
    outline: 3px solid #ffdd00;
    outline-offset: 0;
    box-shadow: none;
    border-color: #0b0c0c;
  }

  .map-search-input-large::placeholder {
    font-size: 1rem;
    line-height: 1.25;
    color: #505a5f;
  }

  .map-search-close {
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    font-size: 32px;
    line-height: 1;
    padding: 0;
    width: 35px;
    height: 35px;
    cursor: pointer;
    color: #0b0c0c;
    font-family: "GDS Transport", arial, sans-serif;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .map-search-close:hover {
    background-color: #f3f2f1;
  }

  .map-search-close:focus {
    outline: none;
  }

  .map-search-close:focus-visible {
    outline: 3px solid #ffdd00;
    outline-offset: 0;
    background-color: #ffdd00;
  }

  .map-search-results-large {
    background-color: white;
    border: 2px solid #0b0c0c;
    border-top: none;
    max-height: 200px;
    overflow-y: auto;
    margin-bottom: 15px;
    margin-top: -10px;
    position: relative;
    z-index: 20; /* Higher than legend overlay (z-index: 10) */
  }

  .map-search-results-list {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .map-search-results-item {
    border-bottom: 1px solid #b1b4b6;
  }

  .map-search-results-item:last-child {
    border-bottom: none;
  }

  .map-search-results-button {
    width: 100%;
    padding: 10px 15px;
    text-align: left;
    background: none;
    border: none;
    cursor: pointer;
    font-family: "GDS Transport", arial, sans-serif;
    font-size: 1rem;
    line-height: 1.25;
    color: #0b0c0c;
  }

  .map-search-results-button strong {
    font-size: 1rem;
    font-weight: 700;
    line-height: 1.25;
  }

  .map-search-results-button:hover {
    background-color: #f3f2f1;
  }

  .map-search-results-button:focus {
    outline: 3px solid #ffdd00;
    outline-offset: 0;
    background-color: #ffdd00;
    color: #0b0c0c;
  }

  /* Map overlay styles */
  /* Map overlay styles */
  .map-overlay {
    z-index: 10;
  }

  .map-overlay .govuk-summary-list {
    font-size: 1rem;
    line-height: 1.25;
  }

  .map-overlay .govuk-summary-list__key,
  .map-overlay .govuk-summary-list__value {
    padding: 5px 0;
    width: 50%;
    font-size: 1rem;
    line-height: 1.25;
  }

  /* Map legend styles */
  .map-legend {
    background-color: white;
    padding: 10px;
    padding-top: 10px; /* Remove extra padding since heading and close are aligned at top */
    border: 2px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1);
    width: 275px; /* 270px + 30px padding = 300px to match search input */
    position: relative; /* For close button positioning */
  }

  .map-legend .govuk-heading-m {
    margin-top: 0;
    padding-right: 40px; /* Space for close button */
  }

  .map-legend-items {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .map-legend-item {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .map-legend-color {
    width: 20px;
    height: 20px;
    border: none; /* Remove border */
    flex-shrink: 0;
  }

  .map-legend-label {
    font-size: 1rem; /* Changed from 0.875rem to 1rem */
    line-height: 1.25;
    color: #0b0c0c;
    font-family: "GDS Transport", arial, sans-serif;
    font-weight: 400;
  }

    .map-overlay-close {
    position: absolute;
    top: 10px;
    right: 10px;
    background: white;
    border: 2px solid #0b0c0c;
    color: #0b0c0c;
    padding: 5px 10px;
    font-size: 1rem; /* Changed from 14px to match map toggle */
    line-height: 1.25;
    font-weight: 700;
    cursor: pointer;
    font-family: "GDS Transport", arial, sans-serif;
    min-width: 60px;
    height: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    }

  .map-overlay-close:hover {
    background-color: #f3f2f1;
  }

  .map-overlay-close:focus {
    outline: none !important;
    box-shadow: none !important;
  }

  .map-overlay-close:focus-visible {
    outline: 3px solid #ffdd00 !important;
    outline-offset: 0;
    box-shadow: inset 0 0 0 4px #0b0c0c !important;
  }

  /* Search toggle button */
  .map-search-toggle {
    background: white !important;
    border: 2px solid rgba(0, 0, 0, 0.1) !important;
    border-radius: 0 !important;
    cursor: pointer;
    padding: 0 !important;
    width: 40px !important;
    height: 40px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1) !important;
    box-sizing: border-box !important;
  }

  .map-search-toggle img {
    width: 24px !important;
    height: 24px !important;
    display: block !important;
  }

  .map-search-toggle:hover {
    background-color: #f3f2f1 !important;
  }

  .map-search-toggle:focus {
    outline: none !important;
    box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1) !important;
  }

  .map-search-toggle:focus-visible {
    outline: 3px solid #ffdd00 !important;
    outline-offset: 0 !important;
    box-shadow: inset 0 0 0 4px #0b0c0c !important;
  }

  /* Search container positioning - absolute so it appears at same position as toggle */
  #search-container {
    position: absolute;
    top: 0;
    left: 0;
    margin-top: 0;
  }

  /* Legend toggle button */
  .map-legend-toggle {
    background: white !important;
    border: 2px solid rgba(0, 0, 0, 0.1) !important;
    border-radius: 0 !important;
    cursor: pointer;
    padding: 0 !important;
    width: 40px !important;
    height: 40px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1) !important;
    box-sizing: border-box !important;
  }

  .map-legend-toggle img {
    width: 24px !important;
    height: 24px !important;
    display: block !important;
  }

  .map-legend-toggle:hover {
    background-color: #f3f2f1 !important;
  }

  .map-legend-toggle:focus {
    outline: none !important;
    box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1) !important;
  }

  .map-legend-toggle:focus-visible {
    outline: 3px solid #ffdd00 !important;
    outline-offset: 0 !important;
    box-shadow: inset 0 0 0 4px #0b0c0c !important;
  }

  /* Search overlay positioning */
  #search-overlay {
    position: absolute !important;
    top: 10px !important;
    left: 10px !important;
    z-index: 15; /* Higher than legend overlay so search results appear on top */
  }

  /* Legend overlay positioning - below search toggle */
  #legend-overlay {
    position: absolute !important;
    top: 64px !important; /* 40px search button + 4px border + 20px gap (increased to match map controls) */
    left: 10px !important;
    z-index: 10;
  }

  /* Legend container positioning - absolute so it appears at same position as toggle */
  #legend-container {
    position: absolute;
    top: 0;
    left: 0;
    margin-top: 0;
  }

  /* Legend close button - matches popup close button */
  .map-legend-close {
    position: absolute;
    top: 10px; /* Aligned with padding */
    right: 4px; /* Aligned with padding */
    background: none;
    border: none;
    font-size: 34px; /* Match popup close button */
    line-height: 1;
    padding: 0;
    width: 30px; /* Match popup close button */
    height: 30px; /* Match popup close button */
    cursor: pointer;
    color: #0b0c0c;
    font-weight: normal;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .map-legend-close:hover {
    background-color: #f3f2f1;
  }

  .map-legend-close:focus {
    outline: 3px solid #ffdd00;
    outline-offset: 0;
    box-shadow: inset 0 0 0 4px #0b0c0c;
  }

  .govuk-button {
    font-size: 1rem;
    line-height: 1.25;
    margin-bottom: 3px;
  }

  .govuk-checkboxes__hint {
    margin-top: -14px;
  }

  /* Hedgerows checkbox label styling */
  #hedgerows-checkbox + .govuk-checkboxes__label {
    font-size: 1rem;
  }

  #parcel-filter {
    font-size: 1rem;
    line-height: 1.25;
    text-transform: uppercase;
  }

  /* Side-by-side filter and select all layout */
  .parcel-controls-row {
    display: flex;
    gap: 15px;
    align-items: flex-end;
    margin-bottom: 15px;
  }

  .filter-input-wrapper {
    flex: 0 0 50%;
  }

  #select-all-container {
    flex: 1;
    display: flex;
    align-items: flex-end;
  }

  #select-all-container .govuk-checkboxes {
    margin-bottom: 0;
  }

  #select-all-container .govuk-checkboxes__item {
    margin-bottom: -10px;
    padding-bottom: 0;
  }

  #select-all-container .govuk-checkboxes__label {
    font-size: 1rem;
    white-space: nowrap;
  }

  /* Maplibre popup styles */
  .maplibregl-popup {
    pointer-events: none !important;
  }

  .maplibregl-popup-content {
    padding: 15px 20px;
    font-size: 1rem;
    line-height: 1.25;
    min-width: 200px;
    font-family: "GDS Transport", arial, sans-serif;
    pointer-events: auto !important;
  }

  .maplibregl-popup-tip {
    pointer-events: auto !important;
  }

  .maplibregl-popup-content:focus {
    outline: none !important;
  }

  .maplibregl-popup-content strong {
    font-size: 1.1875rem;
    line-height: 1.25;
    display: block;
    margin-bottom: 2px;
    font-weight: 700;
  }

  .maplibregl-popup-close-button {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 34px;
    line-height: 1;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #0b0c0c;
    font-family: "GDS Transport", arial, sans-serif;
    pointer-events: auto !important;
    cursor: pointer !important;
    z-index: 10 !important;
    background: none !important;
    border: none !important;
  }

  .maplibregl-popup-close-button:hover {
    background-color: #f3f2f1 !important;
  }

  .maplibregl-popup-close-button:focus {
    outline: none !important;
    background-color: transparent !important;
  }

  .maplibregl-popup-close-button:focus-visible {
    outline: 3px solid #ffdd00 !important;
    outline-offset: 0;
    background-color: #ffdd00 !important;
  }

/* Collapsed overlay state */
.map-overlay-collapsed {
  width: auto;
  height: auto;
  padding: 0; /* Changed from 5px to 0 */
  overflow: visible;
  max-width: none;
}

  .map-overlay-collapsed * {
    display: none;
  }

  .map-overlay-collapsed .map-overlay-close {
    display: flex !important;
    position: static;
    margin: 0;
  }

/* Map style toggle button - positioned above zoom controls */
.map-style-toggle {
  position: absolute;
  top: 10px; /* Position at top with same margin as zoom controls */
  right: 10px;
  z-index: 1;
  background: white;
  border: 2px solid rgba(0, 0, 0, 0.1);
  border-radius: 0;
  cursor: pointer;
  padding: 8px;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1);
  box-sizing: border-box;
}

.map-style-toggle img {
  width: 24px;
  height: 24px;
  display: block;
}

.map-style-toggle:hover {
  background-color: #f3f2f1;
}

.map-style-toggle:focus {
  outline: none !important;
  box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1) !important;
}

.map-style-toggle:focus-visible {
  outline: 3px solid #ffdd00 !important;
  outline-offset: 0;
  box-shadow: inset 0 0 0 4px #0b0c0c !important;
}

/* Custom zoom controls */
.custom-zoom-controls {
  position: absolute;
  top: 64px; /* 40px style toggle + 4px border + 20px gap (increased from 10px) */
  right: 10px;
  z-index: 1;
  display: flex;
  flex-direction: column;
  gap: 0;
  background: white;
  border: 2px solid rgba(0, 0, 0, 0.1);
  border-radius: 0;
  box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1);
}

.custom-zoom-button {
  background: white;
  border: none;
  cursor: pointer;
  padding: 0;
  width: 36px; /* Reduced from 40px so total with 2px border = 40px */
  height: 36px; /* Reduced from 40px so total with 2px border = 40px */
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  color: #0b0c0c;
}

.custom-zoom-button:first-child {
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.custom-zoom-button svg {
  width: 24px;
  height: 24px;
  stroke-width: 2;
}

.custom-zoom-button:hover {
  background-color: #f3f2f1;
}

.custom-zoom-button:focus {
  outline: none;
}

.custom-zoom-button:focus-visible {
  outline: 3px solid #ffdd00;
  outline-offset: 0;
  box-shadow: inset 0 0 0 4px #0b0c0c;
}

#map {
  opacity: 0;
  transition: opacity 0.3s ease-in;
}

#map.ready {
  opacity: 1;
}

/* Map loading overlay */
.map-loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #f3f2f1;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.map-loading-content {
  text-align: left;
  padding: 30px;
}

.map-loading-content .govuk-heading-m {
  margin-bottom: 15px;
}

.map-loading-content .govuk-body {
  margin-bottom: 0;
  color: #505a5f;
}

/* Full-width layout styles */
.govuk-header__container, .govuk-width-container, .app-full-width-container {
  max-width: 100%; /* Makes the container full width */
  padding: 0 15px; /* Adds a bit of padding on the sides for spacing on large screens */
}

.govuk-grid-column-one-third {
  padding-left: 0;
}

/* Reduce font size for specific elements */
.govuk-grid-column-one-third > .govuk-body {
  font-size: 1rem;
  line-height: 1.25;
}

/* Accordion section button (heading) */
.govuk-accordion__section-button {
  font-size: 1.25rem;
}

/* Accordion summary text */
.govuk-accordion__section-summary {
  font-size: 1rem;
  line-height: 1.25;
}

/* Accordion show/hide controls */
.govuk-accordion__show-all {
  font-size: 1rem;
  line-height: 1.25;
}

.govuk-accordion__show-all-text {
  font-size: 1rem;
  line-height: 1.25;
}

.govuk-accordion__section-toggle {
  font-size: 1rem;
  line-height: 1.25;
}

.govuk-accordion__section-toggle-text {
  font-size: 1rem;
  line-height: 1.25;
}

.govuk-checkboxes__input .parcel-checkbox {
  border: 1px dotted red;
}
</style>
{% endblock %}
