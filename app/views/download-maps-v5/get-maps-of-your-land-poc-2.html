{% extends "layouts/main.html" %}

{% from "govuk/components/service-navigation/macro.njk" import govukServiceNavigation %}

{% block header %}
  {{ govukHeader() }}
{{ govukServiceNavigation({
  serviceName: "Land and farm",
  serviceUrl: "#",
  navigation: [
    {
      href: "start",
      text: "Get maps of your land",
      active: true
    },
    {
      href: "#",
      text: "Register land"
    },
    {
      href: "#",
      text: "Transfer land"
    }
  ]
}) }}
{% endblock %}

{% set excludeBeforeContent = true %}

{% block head %}
  {{ super() }}
  <link href="https://unpkg.com/maplibre-gl@4/dist/maplibre-gl.css" rel="stylesheet">
{% endblock %}

{% block pageTitle %}
  Map - Get maps of your land – {{ serviceName }} – GOV.UK Prototype Kit
{% endblock %}

{% block content %}

<div class="app-full-width-container">
  <main>
    <div class="govuk-grid-row">
      <div class="govuk-grid-column-one-third">
        <!-- Title -->
        <h1 class="govuk-heading-m">Map of your land</h1>
        
        <!-- Whole holding information -->
        <p class="govuk-body govuk-!-margin-bottom-0">
          Total area (ha) <span id="sidebar-total-area">0.0000</span>
        </p>
        <p class="govuk-body">
          Total parcels <span id="sidebar-total-parcels">0</span>
        </p>

        {% from "govuk/components/button/macro.njk" import govukButton %}
        {{ govukButton({
          text: "Download map",
          classes: "govuk-!-static-margin-bottom-4"
        }) }}

        <!-- Tabs component for different views -->
        {% from "govuk/components/tabs/macro.njk" import govukTabs %}
        
        {{ govukTabs({
          items: [
            {
              label: "Land parcels",
              id: "land-parcels",
              panel: {
                html: '<p class="govuk-body govuk-!-margin-bottom-0">Selected area (ha) <span id="sidebar-selected-area">0.0000</span></p><p class="govuk-body">Parcels selected <span id="sidebar-selected-count">0 of 0</span></p><div class="govuk-form-group govuk-!-margin-bottom-2"><label class="govuk-label govuk-label--s govuk-!-margin-bottom-1" for="parcel-filter">Filter</label><input class="govuk-input govuk-input--width-10" id="parcel-filter" name="parcelFilter" type="text"></div><div class="scrollable-checkbox-container" id="parcels-list"><p class="govuk-body-s">Loading</p></div>'
              }
            },
            {
              label: "Land covers",
              id: "land-covers",
              panel: {
                html: '<div class="scrollable-checkbox-container" id="land-covers-list"><!-- Will be populated dynamically by JavaScript --></div>'
              }
            },
            {
              label: "Hedgerows",
              id: "hedgerows",
              panel: {
                html: '<div class="govuk-checkboxes govuk-checkboxes--small"><div class="govuk-checkboxes__item"><input class="govuk-checkboxes__input" id="hedgerows-checkbox" name="hedgerows" type="checkbox" value="hedgerows"><label class="govuk-label govuk-checkboxes__label" for="hedgerows-checkbox">Show hedgerows</label></div></div>'
              }
            }
          ]
        }) }}

        <!-- <hr class="govuk-section-break govuk-section-break--m govuk-section-break--visible  govuk-!-static-margin-top-4 govuk-!-static-margin-bottom-2"> -->
      </div>
      <div class="govuk-grid-column-two-thirds">
        <!-- Map area -->
        <div style="position: relative;">
          <div id="map" style="width: 100%; height: 800px;"></div>
          
          <!-- Loading message -->
          <div id="map-loading" class="map-loading-overlay">
            <div class="map-loading-content">
              <h2 class="govuk-heading-m">Loading your land data</h2>
              <p class="govuk-body">Loading land parcels, land cover and hedgerow data...</p>
            </div>
          </div>
          
          <!-- Search overlay (toggle-able, hidden until map loads) -->
          <div id="search-overlay" class="map-overlay" style="display: none;">
            <button id="search-toggle" class="map-search-toggle" aria-label="Show search">
              <img src="/public/images/search.svg" alt="" aria-hidden="true">
            </button>
            
            <!-- Search input in overlay (hidden by default) -->
            <div id="search-container" style="display: none;">
              <form class="map-search-form" id="location-search-form">
                <div class="map-search-wrapper-with-close">
                  <input 
                    class="govuk-input map-search-input-large" 
                    id="location-search" 
                    name="location-search" 
                    type="text"
                    autocomplete="off"
                    placeholder="Search your land">
                  <button type="button" id="search-close" class="map-search-close" aria-label="Close search">×</button>
                </div>
              </form>
              
              <!-- Search results dropdown -->
              <div id="search-results" class="map-search-results-large" style="display: none;">
                <ul class="map-search-results-list" id="search-results-list">
                  <!-- Results will be populated here -->
                </ul>
              </div>
            </div>
          </div>
          
          <!-- Legend overlay (toggle-able, hidden until land covers enabled) -->
          <div id="legend-overlay" class="map-overlay" style="display: none;">
            <button id="legend-toggle" class="map-legend-toggle" aria-label="Show legend">
              <img src="/public/images/list.svg" alt="" aria-hidden="true">
            </button>
            
            <!-- Legend content (hidden by default) -->
            <div id="legend-container" class="map-legend" style="display: none;">
              <button type="button" id="legend-close" class="map-legend-close" aria-label="Close legend">×</button>
              <h3 class="govuk-heading-m govuk-!-margin-bottom-2">Key</h3>
              <div id="legend-content">
                <!-- Will be populated dynamically by JavaScript -->
                <p class="govuk-body-s">No features to display</p>
              </div>
            </div>
          <!-- End legend container -->
        </div>
        <!-- End legend overlay -->
        </div>
      </div>
    </div>
  </main>
</div>

{% endblock %}

{% block pageScripts %}
<script src="https://unpkg.com/maplibre-gl@4/dist/maplibre-gl.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Configuration
    // Land parcels
    // National Trust: 106327021 (13143 parcels)
    // 80 parcels: 106200212
    // 50 parcels: 106172811
    // 33 parcels: 106332870
    // 29 parcels: 106200859
    // UR 12 noon: 106432212 106936676
    // UR 9.30 am: 110438001
    const SBI = '106332870'; // Test SBI 
    let landParcelsData = null;
    let landCoversData = null;
    let hedgeControlData = null;
    let parcelLayers = {};
    let cachedBounds = null; // Cache bounds calculation
    let landCoverTypes = []; // Store unique land cover types
    let activeLandCovers = new Set(); // Track which land covers are currently selected

    // Initialize the map
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        'version': 8,
        'sources': {
          'raster-tiles': {
            'type': 'raster',
            'tiles': [
              'https://tile.openstreetmap.org/{z}/{x}/{y}.png'
            ],
            'tileSize': 256,
            'attribution': '© OpenStreetMap contributors'
          }
        },
        'layers': [
          {
            'id': 'simple-tiles',
            'type': 'raster',
            'source': 'raster-tiles',
            'minzoom': 0,
            'maxzoom': 22
          }
        ]
      }
    });

    // Search marker
    let searchMarker = null;

    // Custom zoom controls will be added in HTML instead of MapLibre default

    // Add scale control
    map.addControl(new maplibregl.ScaleControl({
      maxWidth: 100,
      unit: 'metric'
    }), 'bottom-left');

    // Fetch land parcels from RPA API
    async function fetchLandParcels() {
      try {
        // Request data in EPSG:4326 (WGS84 lat/lng) which Maplibre uses natively
        const url = `https://environment.data.gov.uk/data-services/RPA/LandParcels/wfs?version=2.0.0&request=GetFeature&typeNames=RPA:LandParcels&cql_filter=SBI=${SBI}&srsname=EPSG:4326&outputFormat=application/json`;
        
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }
        
        const data = await response.json();
        landParcelsData = data;
        
        console.log('Loaded parcels:', data);
        console.log('First feature coordinates:', data.features[0]?.geometry.coordinates);
        
        return data;
      } catch (error) {
        console.error('Error fetching land parcels:', error);
        document.getElementById('parcels-list').innerHTML = 
          '<p class="govuk-body-s" style="color: #d4351c;">Error loading parcels. Please check console.</p>';
        return null;
      }
    }

    // Fetch land covers from RPA API
    async function fetchLandCovers() {
      try {
        const url = `https://environment.data.gov.uk/data-services/RPA/LandCovers/wfs?version=2.0.0&request=GetFeature&typeNames=RPA:LandCovers&cql_filter=SBI=${SBI}&srsname=EPSG:4326&outputFormat=application/json`;
        
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }
        
        const data = await response.json();
        landCoversData = data;
        
        console.log('Loaded land covers:', data);
        
        // Extract unique land cover types from DESCRIPTION field
        const types = new Set();
        data.features.forEach(feature => {
          if (feature.properties && feature.properties.DESCRIPTION) {
            types.add(feature.properties.DESCRIPTION);
          }
        });
        landCoverTypes = Array.from(types).sort();
        console.log('Unique land cover types:', landCoverTypes);
        
        return data;
      } catch (error) {
        console.error('Error fetching land covers:', error);
        return null;
      }
    }

    // Fetch hedge control from RPA API
    async function fetchHedgeControl() {
      try {
        const url = `https://environment.data.gov.uk/data-services/RPA/HedgeControl/wfs?version=2.0.0&request=GetFeature&typeNames=RPA:HedgeControl&cql_filter=SBI=${SBI}&srsname=EPSG:4326&outputFormat=application/json`;
        
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }
        
        const data = await response.json();
        hedgeControlData = data;
        
        console.log('Loaded hedge control:', data);
        
        return data;
      } catch (error) {
        console.error('Error fetching hedge control:', error);
        return null;
      }
    }

    // Add parcels to map
    function addParcelsToMap(data) {
      if (!data || !data.features || data.features.length === 0) {
        console.log('No parcel features found');
        return;
      }

      // Add source for all parcels
      map.addSource('land-parcels', {
        type: 'geojson',
        data: data
      });

      // Add fill layer for parcels
      map.addLayer({
        id: 'parcels-fill',
        type: 'fill',
        source: 'land-parcels',
        paint: {
          'fill-color': '#1d70b8', // GOV.UK blue
          'fill-opacity': 0.3
        }
      });

      // Add outline layer for parcels
      map.addLayer({
        id: 'parcels-outline',
        type: 'line',
        source: 'land-parcels',
        paint: {
          'line-color': '#1d70b8',
          'line-width': 2
        }
      });

      // Add highlight layer (initially empty) - SOURCE FIRST
      map.addSource('selected-parcels', {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: []
        }
      });

        // THEN add the layers with explicit visibility
        map.addLayer({
        id: 'selected-parcels-fill',
        type: 'fill',
        source: 'selected-parcels',
        paint: {
            'fill-color': '#ffdd00', // GOV.UK yellow
            'fill-opacity': 0.5
        },
        layout: {
            'visibility': 'visible'
        }
        });

        map.addLayer({
        id: 'selected-parcels-outline',
        type: 'line',
        source: 'selected-parcels',
        paint: {
            'line-color': '#0b0c0c', // GOV.UK black
            'line-width': 3
        },
        layout: {
            'visibility': 'visible'
        }
        });

      // Move selected layers to the top after a brief delay
      setTimeout(() => {
        if (map.getLayer('selected-parcels-fill')) {
          map.moveLayer('selected-parcels-fill');
        }
        if (map.getLayer('selected-parcels-outline')) {
          map.moveLayer('selected-parcels-outline');
        }
      }, 100);

      // Calculate and cache bounds
      if (!cachedBounds) {
        const bounds = new maplibregl.LngLatBounds();

        data.features.forEach(feature => {
          if (feature.geometry.type === 'Polygon') {
            feature.geometry.coordinates[0].forEach(coord => {
              bounds.extend(coord);
            });
          } else if (feature.geometry.type === 'MultiPolygon') {
            feature.geometry.coordinates.forEach(polygon => {
              polygon[0].forEach(coord => {
                bounds.extend(coord);
              });
            });
          }
        });

        cachedBounds = bounds;

        map.fitBounds(cachedBounds, {
          padding: 50,
          duration: 0  // Instant, no animation on initial load
        });

        // Show the map and hide loading overlay
        document.getElementById('map').classList.add('ready');
        
        // Hide loading overlay and show search toggle and legend toggle
        const loadingOverlay = document.getElementById('map-loading');
        const searchOverlay = document.getElementById('search-overlay');
        const legendOverlay = document.getElementById('legend-overlay');
        
        if (loadingOverlay) {
          loadingOverlay.style.display = 'none';
        }
        if (searchOverlay) {
          searchOverlay.style.display = 'block';
          searchOverlay.style.position = 'absolute';
          searchOverlay.style.top = '10px';
          searchOverlay.style.left = '10px';
          searchOverlay.style.zIndex = '15'; // Higher than legend overlay
        }
        if (legendOverlay) {
          legendOverlay.style.display = 'block';
          legendOverlay.style.position = 'absolute';
          legendOverlay.style.top = '64px'; // Increased gap to 20px to match map controls
          legendOverlay.style.left = '10px';
          legendOverlay.style.zIndex = '10';
        }
      }

      // Optimized click handler - single query for all layers
      if (!map._parcelClickHandler) {
        let isProcessingClick = false;
        
        map._parcelClickHandler = (e) => {
          // If already processing a click, ignore this one completely
          if (isProcessingClick) {
            console.log('Click ignored - already processing another click');
            return;
          }
          
          isProcessingClick = true;
          
          // Reset the flag after 100ms
          setTimeout(() => {
            isProcessingClick = false;
          }, 100);
          
          console.log('=== PARCEL CLICK EVENT ===');
          
          // Single query for all relevant layers at once
          const allFeatures = map.queryRenderedFeatures(e.point, {
            layers: ['land-covers-fill', 'hedge-control-line', 'parcels-fill']
          });
          
          // Check what was actually clicked
          const hedgeClicked = allFeatures.some(f => f.layer.id === 'hedge-control-line');
          
          // Only block parcel selection if we clicked directly on a hedge
          // Land covers should not block parcel selection
          if (hedgeClicked) {
            return;
          }
          
          // Find parcel features in the results
          const parcelFeatures = allFeatures.filter(f => f.layer.id === 'parcels-fill');
          
          if (parcelFeatures.length > 0) {
            const feature = parcelFeatures[0];
            const props = feature.properties;
            
            console.log('Parcel clicked:', props);
            
            // Get the full feature from landParcelsData
            const fullFeature = landParcelsData.features.find(f => 
              f.properties.SHEET_ID === props.SHEET_ID && 
              f.properties.PARCEL_ID === props.PARCEL_ID
            );
            
            if (fullFeature) {
              // Check if selected-parcels source exists
              const selectedSource = map.getSource('selected-parcels');
              if (!selectedSource) {
                console.error('selected-parcels source not found');
                return;
              }
              
              // Get current selected parcels
              const currentData = selectedSource._data;
              const currentFeatures = currentData.features || [];
              
              // Check if this parcel is already selected
              const parcelId = `${props.SHEET_ID}${props.PARCEL_ID}`;
              const existingIndex = currentFeatures.findIndex(f => 
                `${f.properties.SHEET_ID}${f.properties.PARCEL_ID}` === parcelId
              );
              
              let newFeatures;
              if (existingIndex !== -1) {
                // Parcel already selected - remove it (toggle off)
                newFeatures = currentFeatures.filter((f, i) => i !== existingIndex);
              } else {
                // Parcel not selected - add it
                newFeatures = [...currentFeatures, fullFeature];
              }
              
              // Update the selected parcels
              console.log('About to update selected parcels, new count:', newFeatures.length);
              console.log('Selected source exists:', !!selectedSource);
              selectedSource.setData({
                type: 'FeatureCollection',
                features: newFeatures
              });
              console.log('Selected parcels data updated successfully');
              
              // Update statistics in the overlay
              // Update statistics in sidebar
              const totalArea = newFeatures.reduce((sum, f) => 
                sum + parseFloat(f.properties.AREA_HA || 0), 0
              );
              // Update sidebar elements
              document.getElementById('sidebar-selected-area').textContent = totalArea.toFixed(4);
              document.getElementById('sidebar-selected-count').textContent = 
                `${newFeatures.length} of ${landParcelsData.features.length}`;
              
              // Also update checkboxes to match
              const checkbox = document.getElementById(`parcel-${parcelId}`);
              if (checkbox) {
                checkbox.checked = existingIndex === -1; // Check if we just added it
              }
            }
            
            // Only show parcel popup if land covers layer is not visible
            const landCoversVisible = map.getLayoutProperty('land-covers-fill', 'visibility') === 'visible';
            if (!landCoversVisible) {
              new maplibregl.Popup()
                .setLngLat(e.lngLat)
                .setHTML(`
                  <h3 class="govuk-heading-m govuk-!-margin-bottom-1">Land parcel</h3>
                  ${props.SHEET_ID} ${props.PARCEL_ID}<br>
                  Total area (ha) ${parseFloat(props.AREA_HA).toFixed(4)}
                `)
                .addTo(map);
            }
          }
        };
      }

      // Remove any existing handler first
      map.off('click', 'parcels-fill', map._parcelClickHandler);

      // Add the handler
      map.on('click', 'parcels-fill', map._parcelClickHandler);
      

      // Change cursor on hover
      map.on('mouseenter', 'parcels-fill', () => {
        map.getCanvas().style.cursor = 'pointer';
      });

      map.on('mouseleave', 'parcels-fill', () => {
        map.getCanvas().style.cursor = '';
      });
    }

    // Add land covers to map
    function addLandCoversToMap(data) {
    if (!data || !data.features || data.features.length === 0) {
        console.log('No land cover features found');
        return;
    }

    // Add source for land covers
    map.addSource('land-covers', {
        type: 'geojson',
        data: data
    });

    // Land cover color mapping using GOV.UK Design System colors
    const landCoverColors = {
        'Permanent Grassland': '#00703c',         // GOV.UK green (dark)
        'Arable Land': '#d4351c',                 // GOV.UK red
        'Temporary Grassland': '#85994b',         // GOV.UK light green/olive
        'Woodland': '#005a30',                    // GOV.UK very dark green
        'Scrub - Ungrazeable': '#f47738',        // GOV.UK orange
        'Notional - Scrub': '#fd0',               // GOV.UK yellow
        'Track - Natural Surface': '#b58840',     // GOV.UK brown
        'Metalled track': '#505a5f',              // GOV.UK dark grey
        'Residential Gardens': '#912b88',         // GOV.UK purple
        'Hard Standings': '#626a6e',              // GOV.UK mid-dark grey
        'Farm Building': '#b1b4b6',               // GOV.UK mid grey
        'Permanent Crops': '#4c2c92',             // GOV.UK dark purple
        'Fallow': '#f3f2f1',                      // GOV.UK light grey
        'Fallow Land': '#f3f2f1',                 // GOV.UK light grey
        'default': '#1d70b8'                      // GOV.UK blue for any unknown types
    };

    // Build color expression for MapLibre
    const colorExpression = ['match', ['get', 'DESCRIPTION']];
    Object.entries(landCoverColors).forEach(([type, color]) => {
        if (type !== 'default') {
            colorExpression.push(type, color);
        }
    });
    colorExpression.push(landCoverColors['default']); // fallback color

    // Add fill layer for land covers with dynamic colors
    map.addLayer({
        id: 'land-covers-fill',
        type: 'fill',
        source: 'land-covers',
        paint: {
            'fill-color': colorExpression,
            'fill-opacity': 0.6
        },
        layout: {
            'visibility': 'none' // Hidden by default
        }
    });

    // Add outline layer for land covers
    map.addLayer({
        id: 'land-covers-outline',
        type: 'line',
        source: 'land-covers',
        paint: {
            'line-color': '#0b0c0c', // Black outline
            'line-width': 1.5
        },
        layout: {
            'visibility': 'none' // Hidden by default
        }
    });

    // Store the handler function so we can remove it later
    if (!map._landCoverClickHandler) {
        map._landCoverClickHandler = (e) => {
        // Check if we clicked on a hedge - if so, don't show land cover popup
        const hedgeFeatures = map.queryRenderedFeatures(e.point, {
            layers: ['hedge-control-line']
        });
        
        if (hedgeFeatures.length > 0) {
            return; // Let the hedge handler take precedence
        }
        
        if (e.features.length > 0) {
            const props = e.features[0].properties;
            
            new maplibregl.Popup()
            .setLngLat(e.lngLat)
            .setHTML(`
                <h3 class="govuk-heading-m govuk-!-margin-bottom-1">Land cover</h3>
                ${props.DESCRIPTION || 'N/A'}<br>
                Land parcel ${props.SHEET_ID || ''} ${props.PARCEL_ID || ''}<br>
                Total area (ha) ${parseFloat(props.AREA_HA || 0).toFixed(4)}<br>
                Code ${props.LAND_COVER_CLASS_CODE || 'N/A'}
            `)
            .addTo(map);
        }
        };
    }

    // Remove any existing handlers first
    map.off('click', 'land-covers-fill', map._landCoverClickHandler);
    map.off('mouseenter', 'land-covers-fill');
    map.off('mouseleave', 'land-covers-fill');

    // Add the handlers
    map.on('click', 'land-covers-fill', map._landCoverClickHandler);

    // Change cursor on hover
    map.on('mouseenter', 'land-covers-fill', () => {
        map.getCanvas().style.cursor = 'pointer';
    });

    map.on('mouseleave', 'land-covers-fill', () => {
        map.getCanvas().style.cursor = '';
    });
    }
    

    // Add hedge control to map
    function addHedgeControlToMap(data) {
      if (!data || !data.features || data.features.length === 0) {
        console.log('No hedge control features found');
        return;
      }

      // Add source for hedge control
      map.addSource('hedge-control', {
        type: 'geojson',
        data: data
      });

      // Add line layer for hedges
      map.addLayer({
        id: 'hedge-control-line',
        type: 'line',
        source: 'hedge-control',
        paint: {
          'line-color': '#912b88', // GOV.UK purple
          'line-width': 3
        },
        layout: {
          'visibility': 'none' // Hidden by default
        }
      });

      // Store the handler function so we can remove it later
      if (!map._hedgeClickHandler) {
        map._hedgeClickHandler = (e) => {
          // Stop the event from propagating to layers below
          e.preventDefault();
          
          if (e.features.length > 0) {
            const props = e.features[0].properties;
            
            new maplibregl.Popup()
              .setLngLat(e.lngLat)
              .setHTML(`
                <strong>Hedgerow</strong><br>
                Length (m): ${parseFloat(props.LENGTH || 0).toFixed(2)}<br>
                Land parcel: ${props.REF_PARCEL_SHEET_ID || ''} ${props.REF_PARCEL_PARCEL_ID || ''}
              `)
              .addTo(map);
          }
        };
      }

      // Remove any existing handlers first
      map.off('click', 'hedge-control-line', map._hedgeClickHandler);
      map.off('mouseenter', 'hedge-control-line');
      map.off('mouseleave', 'hedge-control-line');

      // Add the handlers
      map.on('click', 'hedge-control-line', map._hedgeClickHandler);

      // Change cursor on hover
      map.on('mouseenter', 'hedge-control-line', () => {
        map.getCanvas().style.cursor = 'pointer';
      });

      map.on('mouseleave', 'hedge-control-line', () => {
        map.getCanvas().style.cursor = '';
      });
    }

    // Clear highlights when clicking on the map background (not on a parcel)
    map.on('click', (e) => {
      const features = map.queryRenderedFeatures(e.point, {
        layers: ['parcels-fill']
      });
      
      const selectedValue = document.querySelector('input[name="changedName"]:checked')?.value;
      
      // If no parcel was clicked and we're in "whole holding" mode, clear everything
      if (features.length === 0 && selectedValue === 'whole-holding') {
        const selectedSource = map.getSource('selected-parcels');
        if (selectedSource) {
          selectedSource.setData({
            type: 'FeatureCollection',
            features: []
          });
        }
      }
      
      // In individual parcels mode, clicking background doesn't clear selections
    });

    // Create parcel checkboxes
    function createParcelCheckboxes(data) {
      if (!data || !data.features || data.features.length === 0) {
        document.getElementById('parcels-list').innerHTML = 
          '<p class="govuk-body-s">No parcels found for this SBI.</p>';
        return;
      }

      const parcels = data.features.map(f => ({
        id: `${f.properties.SHEET_ID}${f.properties.PARCEL_ID}`,
        sheetId: f.properties.SHEET_ID,
        parcelId: f.properties.PARCEL_ID,
        area: f.properties.AREA_HA,
        feature: f
      }));

      // Sort parcels by ID
      parcels.sort((a, b) => a.id.localeCompare(b.id));

      // Calculate totals and update sidebar elements
      const totalArea = parcels.reduce((sum, p) => sum + parseFloat(p.area || 0), 0);
      document.getElementById('sidebar-total-area').textContent = totalArea.toFixed(4);
      document.getElementById('sidebar-total-parcels').textContent = parcels.length;
      document.getElementById('sidebar-selected-count').textContent = `0 of ${parcels.length}`;

      // Create checkboxes HTML
      let checkboxesHTML = '<div class="govuk-checkboxes govuk-checkboxes--small" data-module="govuk-checkboxes">';
      
      // Add "Select all" checkbox at the top
      checkboxesHTML += `
        <div class="govuk-checkboxes__item">
          <input class="govuk-checkboxes__input" 
                 id="select-all-parcels" 
                 name="selectAllParcels" 
                 type="checkbox">
          <label class="govuk-label govuk-checkboxes__label" for="select-all-parcels">
            Select all land parcels
          </label>
        </div>
      `;
      
      parcels.forEach(parcel => {
        checkboxesHTML += `
          <div class="govuk-checkboxes__item">
            <input class="govuk-checkboxes__input parcel-checkbox" 
                   id="parcel-${parcel.id}" 
                   name="landParcels" 
                   type="checkbox" 
                   value="${parcel.id}"
                   data-area="${parcel.area}">
            <label class="govuk-label govuk-checkboxes__label" for="parcel-${parcel.id}">
              ${parcel.sheetId} ${parcel.parcelId}
            </label>
            <div class="govuk-hint govuk-checkboxes__hint">
              ${parseFloat(parcel.area).toFixed(4)} (ha)
            </div>
          </div>
        `;
      });
      
      checkboxesHTML += '</div>';
      
      document.getElementById('parcels-list').innerHTML = checkboxesHTML;

      // Add event listener to "Select all" checkbox
      const selectAllCheckbox = document.getElementById('select-all-parcels');
      if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', function() {
          const parcelCheckboxes = document.querySelectorAll('.parcel-checkbox');
          parcelCheckboxes.forEach(checkbox => {
            checkbox.checked = this.checked;
          });
          updateSelectedParcels();
        });
      }

      // Add event listeners to individual parcel checkboxes
      document.querySelectorAll('.parcel-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          updateSelectedParcels();
          
          // Update "Select all" checkbox state
          const allCheckboxes = document.querySelectorAll('.parcel-checkbox');
          const checkedCheckboxes = document.querySelectorAll('.parcel-checkbox:checked');
          if (selectAllCheckbox) {
            selectAllCheckbox.checked = allCheckboxes.length === checkedCheckboxes.length;
            selectAllCheckbox.indeterminate = checkedCheckboxes.length > 0 && checkedCheckboxes.length < allCheckboxes.length;
          }
        });
      });
    }

    // Update selected parcels on map
    function updateSelectedParcels() {
      const selectedCheckboxes = document.querySelectorAll('.parcel-checkbox:checked');
      const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.value);
      
      // Filter features for selected parcels
      const selectedFeatures = landParcelsData.features.filter(f => {
        const id = `${f.properties.SHEET_ID}${f.properties.PARCEL_ID}`;
        return selectedIds.includes(id);
      });

      // Update selected parcels source
      const selectedSource = map.getSource('selected-parcels');
      if (selectedSource) {
        selectedSource.setData({
          type: 'FeatureCollection',
          features: selectedFeatures
        });

        // Calculate selected area
        const selectedArea = Array.from(selectedCheckboxes)
          .reduce((sum, cb) => sum + parseFloat(cb.dataset.area || 0), 0);
        
        // Update sidebar elements
        document.getElementById('sidebar-selected-area').textContent = selectedArea.toFixed(4);
        document.getElementById('sidebar-selected-count').textContent = 
          `${selectedCheckboxes.length} of ${landParcelsData.features.length}`;
      }
    }

    // Setup tab-based view controls
    function setupTabControls() {
      // Land cover color mapping using GOV.UK Design System colors - high contrast
      // Based on actual RPA API land cover descriptions
      const landCoverColors = {
        'Permanent Grassland': '#00703c',         // GOV.UK green (dark)
        'Arable Land': '#d4351c',                 // GOV.UK red
        'Temporary Grassland': '#85994b',         // GOV.UK light green/olive
        'Woodland': '#005a30',                    // GOV.UK very dark green
        'Scrub - Ungrazeable': '#f47738',        // GOV.UK orange
        'Notional - Scrub': '#fd0',               // GOV.UK yellow
        'Track - Natural Surface': '#b58840',     // GOV.UK brown
        'Metalled track': '#505a5f',              // GOV.UK dark grey
        'Residential Gardens': '#912b88',         // GOV.UK purple
        'Hard Standings': '#626a6e',              // GOV.UK mid-dark grey
        'Farm Building': '#b1b4b6',               // GOV.UK mid grey
        'Permanent Crops': '#4c2c92',             // GOV.UK dark purple
        'Fallow': '#f3f2f1',                      // GOV.UK light grey
        'Fallow Land': '#f3f2f1',                 // GOV.UK light grey
        'default': '#1d70b8'                      // GOV.UK blue for any unknown types
      };

      // Function to populate individual land cover checkboxes
      function populateLandCoverCheckboxes() {
        const container = document.getElementById('land-covers-list');
        if (!container || landCoverTypes.length === 0) return;

        const checkboxesHTML = landCoverTypes.map((type, index) => {
          const color = landCoverColors[type] || landCoverColors['default'];
          const sanitizedValue = type.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
          return `
            <div class="govuk-checkboxes__item">
              <input class="govuk-checkboxes__input land-cover-checkbox" 
                     id="land-cover-${sanitizedValue}" 
                     name="land-cover" 
                     type="checkbox" 
                     value="${type}">
              <label class="govuk-label govuk-checkboxes__label" for="land-cover-${sanitizedValue}">
                ${type}
              </label>
            </div>
          `;
        }).join('');

        container.innerHTML = `
          <div class="govuk-checkboxes govuk-checkboxes--small">
            ${checkboxesHTML}
          </div>
        `;

        // Add event listeners to individual land cover checkboxes
        document.querySelectorAll('.land-cover-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', function() {
            const landCoverType = this.value;
            
            if (this.checked) {
              activeLandCovers.add(landCoverType);
            } else {
              activeLandCovers.delete(landCoverType);
            }
            
            // Update the map filter
            updateLandCoverFilter();
            
            // Update legend
            updateLegendForLandCovers();
          });
        });
      }

      // Function to update land cover filter based on selected types
      function updateLandCoverFilter() {
        if (!map.getLayer('land-covers-fill')) return;

        if (activeLandCovers.size === 0) {
          // If no land covers selected, hide the layers
          map.setLayoutProperty('land-covers-fill', 'visibility', 'none');
          map.setLayoutProperty('land-covers-outline', 'visibility', 'none');
        } else {
          // Show layers and apply filter
          map.setLayoutProperty('land-covers-fill', 'visibility', 'visible');
          map.setLayoutProperty('land-covers-outline', 'visibility', 'visible');

          // Create filter expression: show only selected land cover types
          const filter = ['in', ['get', 'DESCRIPTION'], ['literal', Array.from(activeLandCovers)]];
          map.setFilter('land-covers-fill', filter);
          map.setFilter('land-covers-outline', filter);
        }
      }

      // Function to get predominant land cover for a parcel (kept for reference but not actively used)
      function getParcelLandCover(parcelId) {
        if (!landCoversData || !landCoversData.features) return null;
        
        // Find land covers that intersect with this parcel
        const parcelFeature = landParcelsData.features.find(f => 
          `${f.properties.SHEET_ID}${f.properties.PARCEL_ID}` === parcelId
        );
        
        if (!parcelFeature) return null;
        
        // Find the first land cover feature that matches this parcel
        const landCover = landCoversData.features.find(lc => 
          lc.properties.SHEET_ID === parcelFeature.properties.SHEET_ID &&
          lc.properties.PARCEL_ID === parcelFeature.properties.PARCEL_ID
        );
        
        return landCover ? landCover.properties.DESCRIPTION : null;
      }

      // Function to toggle legend visibility
      function toggleLegend(show) {
        const legendOverlay = document.getElementById('legend-overlay');
        if (legendOverlay) {
          // Always show the legend overlay (toggle button), but update content
          legendOverlay.style.display = 'block';
          
          // Update legend content based on whether land covers are enabled
          updateLegendContent(show);
        }
      }
      
      // Function to populate legend with actual land cover types
      function updateLegendContent(landCoversEnabled) {
        const legendContent = document.getElementById('legend-content');
        if (!legendContent) return;
        
        if (!landCoversEnabled || !landCoversData || activeLandCovers.size === 0) {
          // Show "no features" message
          legendContent.innerHTML = '<p class="govuk-body">No features to display</p>';
          return;
        }
        
        // Build legend HTML for selected land covers only
        let html = '<div class="map-legend-items">';
        
        // Sort selected land covers by name
        const sortedLandCovers = Array.from(activeLandCovers).sort();
        
        sortedLandCovers.forEach(landUse => {
          const color = landCoverColors[landUse] || landCoverColors['default'];
          html += `
            <div class="map-legend-item">
              <span class="map-legend-color" style="background-color: ${color};"></span>
              <span class="map-legend-label">${landUse}</span>
            </div>
          `;
        });
        
        html += '</div>';
        html += '<p class="govuk-body-s govuk-!-margin-top-2 govuk-!-margin-bottom-0">Individual land covers are displayed with distinct colours within parcels.</p>';
        legendContent.innerHTML = html;
      }
      
      // Legend toggle functionality
      function showLegend() {
        const legendContainer = document.getElementById('legend-container');
        const legendToggle = document.getElementById('legend-toggle');
        if (legendContainer && legendToggle) {
          legendContainer.style.display = 'block';
          legendToggle.style.display = 'none';
        }
      }
      
      function hideLegend() {
        const legendContainer = document.getElementById('legend-container');
        const legendToggle = document.getElementById('legend-toggle');
        if (legendContainer && legendToggle) {
          legendContainer.style.display = 'none';
          legendToggle.style.display = 'block';
        }
      }
      
      const legendToggle = document.getElementById('legend-toggle');
      const legendClose = document.getElementById('legend-close');
      
      if (legendToggle) {
        legendToggle.addEventListener('click', showLegend);
      }
      
      if (legendClose) {
        legendClose.addEventListener('click', hideLegend);
      }
      
      // Populate land covers checkboxes when tab is first accessed
      const landCoversTab = document.querySelector('a[href="#land-covers"]');
      if (landCoversTab) {
        landCoversTab.addEventListener('click', function() {
          const landCoversList = document.getElementById('land-covers-list');
          if (landCoversList && landCoversList.querySelector('.govuk-checkboxes') === null) {
            populateLandCoverCheckboxes();
          }
        });
      }
      
      // Handle hedgerows checkbox in hedgerows tab
      const hedgerowsCheckbox = document.getElementById('hedgerows-checkbox');
      if (hedgerowsCheckbox) {
        hedgerowsCheckbox.addEventListener('change', function() {
          const legendOverlay = document.getElementById('legend-overlay');
          
          // Show/hide hedgerows on map
          if (map.getLayer('hedge-control-line')) {
            map.setLayoutProperty('hedge-control-line', 'visibility', 
              this.checked ? 'visible' : 'none');
          }
          
          // Show/hide legend overlay
          if (legendOverlay) {
            legendOverlay.style.display = this.checked ? 'block' : 'none';
          }
        });
      }
      
      // Function to update legend based on active land covers
      function updateLegendForLandCovers() {
        const legendContent = document.getElementById('legend-content');
        const legendOverlay = document.getElementById('legend-overlay');
        if (!legendContent) return;
        
        let html = '';
        let hasContent = false;
        
        // Add land covers to legend if any are selected
        if (activeLandCovers.size > 0) {
          hasContent = true;
          html += '<div class="map-legend-items">';
          const sortedLandCovers = Array.from(activeLandCovers).sort();
          sortedLandCovers.forEach(landUse => {
            const color = landCoverColors[landUse] || landCoverColors['default'];
            html += `
              <div class="map-legend-item">
                <span class="map-legend-color" style="background-color: ${color};"></span>
                <span class="map-legend-label">${landUse}</span>
              </div>
            `;
          });
          html += '</div>';
        }
        
        if (!hasContent) {
          legendContent.innerHTML = '<p class="govuk-body">No features to display</p>';
          // Hide legend overlay if nothing to show
          if (legendOverlay) {
            legendOverlay.style.display = 'none';
          }
        } else {
          legendContent.innerHTML = html;
          // Show legend overlay if we have content
          if (legendOverlay) {
            legendOverlay.style.display = 'block';
          }
        }
      }
    }

    // Debounce helper function
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Location search functionality
    const searchForm = document.getElementById('location-search-form');
    const searchInput = document.getElementById('location-search');
    const searchResults = document.getElementById('search-results');
    const searchResultsList = document.getElementById('search-results-list');

    function simplifyDisplayName(displayName) {
      let parts = displayName.split(',').map(part => part.trim());
      const unwantedTerms = ['England', 'United Kingdom', 'UK'];
      
      parts = parts.filter((part, index) => {
        if (unwantedTerms.some(term => part === term)) {
          return false;
        }
        if (index === parts.length - 2 && parts[parts.length - 1] === 'England') {
          return false;
        }
        if (index === parts.length - 3 && parts[parts.length - 1] === 'United Kingdom') {
          return false;
        }
        return true;
      });
      
      return parts.slice(0, 3).join(', ');
    }

    // Search parcels by ID
    function searchParcels(query) {
      if (!landParcelsData || !landParcelsData.features) {
        return [];
      }

      const searchTerm = query.toLowerCase().replace(/\s+/g, '');
      
      return landParcelsData.features.filter(feature => {
        const parcelId = `${feature.properties.SHEET_ID}${feature.properties.PARCEL_ID}`.toLowerCase();
        const parcelIdWithSpace = `${feature.properties.SHEET_ID} ${feature.properties.PARCEL_ID}`.toLowerCase();
        return parcelId.includes(searchTerm) || parcelIdWithSpace.includes(query.toLowerCase());
      }).map(feature => ({
        type: 'parcel',
        feature: feature,
        displayName: `${feature.properties.SHEET_ID} ${feature.properties.PARCEL_ID}`,
        area: feature.properties.AREA_HA
      }));
    }

    async function searchLocation(query) {
      if (query.length < 2) {
        searchResults.style.display = 'none';
        return;
      }

      // First, search for matching parcels
      const parcelResults = searchParcels(query);
      
      // Then search for locations
      let locationResults = [];
      if (query.length >= 3) {
        try {
          const response = await fetch(
            `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=3&countrycodes=gb`
          );
          locationResults = await response.json();
          locationResults = locationResults.map(result => ({
            type: 'location',
            data: result,
            displayName: simplifyDisplayName(result.display_name)
          }));
        } catch (error) {
          console.error('Search error:', error);
        }
      }

      // Combine results (parcels first)
      const allResults = [...parcelResults, ...locationResults];

      if (allResults.length > 0) {
        displaySearchResults(allResults);
      } else {
        searchResults.style.display = 'none';
      }
    }

    function displaySearchResults(results) {
      searchResultsList.innerHTML = '';
      
      results.forEach(result => {
        const li = document.createElement('li');
        li.className = 'map-search-results-item';
        
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'map-search-results-button';
        
        if (result.type === 'parcel') {
          button.innerHTML = `
            <strong>${result.displayName}</strong><br>
            <span style="font-size: 14px; color: #505a5f;">Total area (ha) ${parseFloat(result.area).toFixed(4)}</span>
          `;
          button.addEventListener('click', () => {
            selectParcel(result.feature);
          });
        } else {
          button.textContent = result.displayName;
          button.addEventListener('click', () => {
            selectLocation(result.data);
          });
        }
        
        li.appendChild(button);
        searchResultsList.appendChild(li);
      });
      
      searchResults.style.display = 'block';
    }

    function selectParcel(feature) {
      // Calculate bounds of the parcel
      const bounds = new maplibregl.LngLatBounds();
      
      if (feature.geometry.type === 'Polygon') {
        feature.geometry.coordinates[0].forEach(coord => {
          bounds.extend(coord);
        });
      } else if (feature.geometry.type === 'MultiPolygon') {
        feature.geometry.coordinates.forEach(polygon => {
          polygon[0].forEach(coord => {
            bounds.extend(coord);
          });
        });
      }

      // Fit map to parcel bounds with padding
      map.fitBounds(bounds, { 
        padding: 100,
        duration: 2000
      });

      // Update search input
      searchInput.value = `${feature.properties.SHEET_ID} ${feature.properties.PARCEL_ID}`;
      searchResults.style.display = 'none';

      // Highlight the parcel
      const selectedSource = map.getSource('selected-parcels');
      if (selectedSource) {
        selectedSource.setData({
          type: 'FeatureCollection',
          features: [feature]
        });
      }

      // Show popup
      const center = bounds.getCenter();
      new maplibregl.Popup()
        .setLngLat(center)
        .setHTML(`
          <strong>Land parcel</strong><br>
          ${feature.properties.SHEET_ID} ${feature.properties.PARCEL_ID}<br>
          Total area (ha): ${parseFloat(feature.properties.AREA_HA).toFixed(4)}
        `)
        .addTo(map);
    }

    function selectLocation(result) {
      const lat = parseFloat(result.lat);
      const lon = parseFloat(result.lon);
      
      map.flyTo({
        center: [lon, lat],
        zoom: 15,
        duration: 2000
      });

      if (searchMarker) {
        searchMarker.remove();
      }

      searchMarker = new maplibregl.Marker({
        color: '#1d70b8'
      })
        .setLngLat([lon, lat])
        .addTo(map);

      searchInput.value = simplifyDisplayName(result.display_name);
      searchResults.style.display = 'none';
    }

    searchForm.addEventListener('submit', (e) => {
      e.preventDefault();
      
      const firstResult = searchResultsList.querySelector('.map-search-results-button');
      if (firstResult && searchResults.style.display !== 'none') {
        firstResult.click();
      }
    });

    const debouncedSearch = debounce((query) => {
      searchLocation(query);
    }, 300);

    searchInput.addEventListener('input', (e) => {
      debouncedSearch(e.target.value.trim());
    });

    document.addEventListener('click', (e) => {
      if (!searchForm.contains(e.target) && !searchResults.contains(e.target)) {
        searchResults.style.display = 'none';
      }
    });

    // Search toggle functionality
    const searchToggle = document.getElementById('search-toggle');
    const searchContainer = document.getElementById('search-container');
    const searchClose = document.getElementById('search-close');
    const filterInput = document.getElementById('parcel-filter');
    
    function hideSearch() {
      searchContainer.style.display = 'none';
      searchToggle.style.display = 'flex';
      searchToggle.setAttribute('aria-label', 'Show search');
      searchInput.value = '';
      searchResults.style.display = 'none';
    }
    
    function showSearch() {
      searchContainer.style.display = 'block';
      searchToggle.style.display = 'none';
      searchToggle.setAttribute('aria-label', 'Hide search');
      setTimeout(() => searchInput.focus(), 100);
    }
    
    if (searchToggle && searchContainer) {
      searchToggle.addEventListener('click', showSearch);
    }
    
    if (searchClose) {
      searchClose.addEventListener('click', hideSearch);
    }
    
    
    function filterParcels() {
      const filterValue = filterInput.value.toLowerCase();
      const parcelItems = document.querySelectorAll('#parcels-list .govuk-checkboxes__item');
      
      parcelItems.forEach(item => {
        const label = item.querySelector('.govuk-checkboxes__label');
        const labelText = label ? label.textContent.toLowerCase() : '';
        
        if (labelText.includes(filterValue)) {
          item.style.display = '';
        } else {
          item.style.display = 'none';
        }
      });
    }
    
    // Debounced filter function
    if (filterInput) {
      const debouncedFilter = debounce(filterParcels, 150);
      filterInput.addEventListener('input', debouncedFilter);
    }

    // Load parcels when map is ready - THIS MUST BE LAST
    map.on('load', function() {
    // Create and add style toggle button with icon
    const styleToggle = document.createElement('button');
    styleToggle.id = 'style-toggle';
    styleToggle.className = 'map-style-toggle';
    styleToggle.setAttribute('aria-label', 'Switch to satellite view');
    styleToggle.setAttribute('title', 'Switch to satellite view'); // Tooltip on hover

    // Add icon as background image
    styleToggle.innerHTML = '<img src="/public/images/map.svg" alt="" aria-hidden="true">';

    // Add to map container
    document.getElementById('map').appendChild(styleToggle);
      
      // Create custom zoom controls
      const zoomControls = document.createElement('div');
      zoomControls.className = 'custom-zoom-controls';
      
      const zoomIn = document.createElement('button');
      zoomIn.className = 'custom-zoom-button';
      zoomIn.setAttribute('aria-label', 'Zoom in');
      zoomIn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
      zoomIn.addEventListener('click', () => map.zoomIn());
      
      const zoomOut = document.createElement('button');
      zoomOut.className = 'custom-zoom-button';
      zoomOut.setAttribute('aria-label', 'Zoom out');
      zoomOut.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
      zoomOut.addEventListener('click', () => map.zoomOut());
      
      zoomControls.appendChild(zoomIn);
      zoomControls.appendChild(zoomOut);
      document.getElementById('map').appendChild(zoomControls);
      
      let currentStyle = 'streets';
      styleToggle.addEventListener('click', () => {
        // Store current view before switching
        const currentCenter = map.getCenter();
        const currentZoom = map.getZoom();
        const currentBearing = map.getBearing();
        const currentPitch = map.getPitch();
        
        if (currentStyle === 'streets') {
          // Switch to satellite
          map.setStyle({
            'version': 8,
            'sources': {
              'satellite-tiles': {
                'type': 'raster',
                'tiles': [
                  'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
                ],
                'tileSize': 256,
                'attribution': '© Esri, Maxar, Earthstar Geographics'
              }
            },
            'layers': [
              {
                'id': 'satellite',
                'type': 'raster',
                'source': 'satellite-tiles',
                'minzoom': 0,
                'maxzoom': 22
              }
            ]
          });
          currentStyle = 'satellite';
          styleToggle.setAttribute('aria-label', 'Switch to map view');
          styleToggle.setAttribute('title', 'Switch to map view');
        } else {  
          // Switch to streets
          map.setStyle({
            'version': 8,
            'sources': {
              'raster-tiles': {
                'type': 'raster',
                'tiles': [
                  'https://tile.openstreetmap.org/{z}/{x}/{y}.png'
                ],
                'tileSize': 256,
                'attribution': '© OpenStreetMap contributors'
              }
            },
            'layers': [
              {
                'id': 'simple-tiles',
                'type': 'raster',
                'source': 'raster-tiles',
                'minzoom': 0,
                'maxzoom': 22
              }
            ]
          });
          currentStyle = 'streets';
          styleToggle.setAttribute('aria-label', 'Switch to satellite view');
          styleToggle.setAttribute('title', 'Switch to satellite view');
        }
        
        // Remove focus after click
        styleToggle.blur();
        
        // Re-add your data layers after style change
        map.once('styledata', () => {
          // Restore the view position
          map.jumpTo({
            center: currentCenter,
            zoom: currentZoom,
            bearing: currentBearing,
            pitch: currentPitch
          });
          
          // setStyle() already removes all layers and sources, so we just re-add
          if (landParcelsData) {
            addParcelsToMap(landParcelsData);
          }
          if (landCoversData) {
            addLandCoversToMap(landCoversData);
          }
          if (hedgeControlData) {
            addHedgeControlToMap(hedgeControlData);
          }
          
          // Re-setup controls
          setupTabControls();
          
          // Restore the current selection state for parcels
          updateSelectedParcels();
          
          // Restore data layer visibility based on checkboxes
          const landCoversCheckbox = document.querySelector('input[name="dataLayers"][value="land-covers"]');
          const hedgerowsCheckbox = document.querySelector('input[name="dataLayers"][value="hedgerows"]');
          
          if (landCoversCheckbox && landCoversCheckbox.checked && activeLandCovers.size > 0) {
            // Restore land cover filter
            updateLandCoverFilter();
          }
          
          if (hedgerowsCheckbox && hedgerowsCheckbox.checked) {
            // Restore hedgerows visibility
            if (map.getLayer('hedge-control-line')) {
              map.setLayoutProperty('hedge-control-line', 'visibility', 'visible');
            }
          }
        });
      });

      // OPTIMIZED: Fetch all data in parallel with Promise.all
      (async () => {
        const [parcelsData, coversData, hedgesData] = await Promise.all([
          fetchLandParcels(),
          fetchLandCovers(),
          fetchHedgeControl()
        ]);
        
        if (parcelsData) {
          addParcelsToMap(parcelsData);
          createParcelCheckboxes(parcelsData);
        }
        
        if (coversData) {
          addLandCoversToMap(coversData);
        }
        
        if (hedgesData) {
          addHedgeControlToMap(hedgesData);
        }
        
        // Set up radio button listeners for view selection
        setupTabControls();
      })();
    });
  });
</script>

<style>
  .scrollable-checkbox-container {
    max-height: 325px;
    overflow-y: auto;
    overflow-x: visible;
    margin-left: -15px;
    padding-left: 15px;
    padding-right: 10px;
    margin-bottom: 30px;
  }
  
  /* Two-column grid layout for parcel checkboxes */
  #parcels-list .govuk-checkboxes {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0 15px; /* Horizontal gap only */
  }
  
  /* Single column layout for land cover checkboxes */
  #land-covers-list .govuk-checkboxes {
    display: block; /* Single column */
  }
  
  /* Make parcel checkboxes display inline in columns */
  .scrollable-checkbox-container .govuk-checkboxes__label {
    font-size: 1rem;
    line-height: 1.25;
  }
  
  .scrollable-checkbox-container .govuk-checkboxes__hint {
    font-size: 1rem;
    line-height: 1.25;
    padding-right: 0px;
    margin-top: -14px;
  }
  
  /* Remove bottom margin from hints in parcels list for cleaner inline layout */
  #parcels-list .govuk-checkboxes__hint {
    margin-bottom: 0;
  }
  
  .govuk-radios__label {
    font-size: 1rem;
    line-height: 1.25;
  }
  
  .scrollable-checkbox-container::-webkit-scrollbar {
    width: 8px;
  }
  
  .scrollable-checkbox-container::-webkit-scrollbar-track {
    background: #f1f1f1;
  }
  
  .scrollable-checkbox-container::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 0px;
  }
  
  .scrollable-checkbox-container::-webkit-scrollbar-thumb:hover {
    background: #555;
  }

  /* Map search styles - inline in overlay */
  /* Map search styles - larger input with close button */
  .map-search-form {
    margin-bottom: 0;
  }

  .map-search-wrapper-with-close {
    position: relative;
    margin-bottom: 10px;
  }

  .map-search-input-large {
    font-size: 1rem;
    line-height: 1.25;
    padding: 13px 45px 13px 12px;
    width: 100%;
    min-width: 300px;
    border: 2px solid #0b0c0c;
  }

  .map-search-input-large:focus {
    outline: 3px solid #ffdd00;
    outline-offset: 0;
    box-shadow: none;
    border-color: #0b0c0c;
  }

  .map-search-input-large::placeholder {
    font-size: 1rem;
    line-height: 1.25;
    color: #505a5f;
  }

  .map-search-close {
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    font-size: 32px;
    line-height: 1;
    padding: 0;
    width: 35px;
    height: 35px;
    cursor: pointer;
    color: #0b0c0c;
    font-family: "GDS Transport", arial, sans-serif;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .map-search-close:hover {
    background-color: #f3f2f1;
  }

  .map-search-close:focus {
    outline: none;
  }

  .map-search-close:focus-visible {
    outline: 3px solid #ffdd00;
    outline-offset: 0;
    background-color: #ffdd00;
  }

  .map-search-results-large {
    background-color: white;
    border: 2px solid #0b0c0c;
    border-top: none;
    max-height: 200px;
    overflow-y: auto;
    margin-bottom: 15px;
    margin-top: -10px;
    position: relative;
    z-index: 20; /* Higher than legend overlay (z-index: 10) */
  }

  .map-search-results-list {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .map-search-results-item {
    border-bottom: 1px solid #b1b4b6;
  }

  .map-search-results-item:last-child {
    border-bottom: none;
  }

  .map-search-results-button {
    width: 100%;
    padding: 10px 15px;
    text-align: left;
    background: none;
    border: none;
    cursor: pointer;
    font-family: "GDS Transport", arial, sans-serif;
    font-size: 1rem;
    line-height: 1.25;
    color: #0b0c0c;
  }

  .map-search-results-button strong {
    font-size: 1rem;
    font-weight: 700;
    line-height: 1.25;
  }

  .map-search-results-button:hover {
    background-color: #f3f2f1;
  }

  .map-search-results-button:focus {
    outline: 3px solid #ffdd00;
    outline-offset: 0;
    background-color: #ffdd00;
    color: #0b0c0c;
  }

  /* Map overlay styles */
  /* Map overlay styles */
  .map-overlay {
    z-index: 10;
  }

  .map-overlay .govuk-summary-list {
    font-size: 1rem;
    line-height: 1.25;
  }

  .map-overlay .govuk-summary-list__key,
  .map-overlay .govuk-summary-list__value {
    padding: 5px 0;
    width: 50%;
    font-size: 1rem;
    line-height: 1.25;
  }
  
  /* Map legend styles */
  .map-legend {
    background-color: white;
    padding: 10px;
    padding-top: 10px; /* Remove extra padding since heading and close are aligned at top */
    border: 2px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1);
    width: 275px; /* 270px + 30px padding = 300px to match search input */
    position: relative; /* For close button positioning */
  }

  .map-legend .govuk-heading-m {
    margin-top: 0;
    padding-right: 40px; /* Space for close button */
  }

  .map-legend-items {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .map-legend-item {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .map-legend-color {
    width: 20px;
    height: 20px;
    border: none; /* Remove border */
    flex-shrink: 0;
  }

  .map-legend-label {
    font-size: 1rem; /* Changed from 0.875rem to 1rem */
    line-height: 1.25;
    color: #0b0c0c;
    font-family: "GDS Transport", arial, sans-serif;
    font-weight: 400;
  }
  
    .map-overlay-close {
    position: absolute;
    top: 10px;
    right: 10px;
    background: white;
    border: 2px solid #0b0c0c;
    color: #0b0c0c;
    padding: 5px 10px;
    font-size: 1rem; /* Changed from 14px to match map toggle */
    line-height: 1.25;
    font-weight: 700;
    cursor: pointer;
    font-family: "GDS Transport", arial, sans-serif;
    min-width: 60px;
    height: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    }

  .map-overlay-close:hover {
    background-color: #f3f2f1;
  }

  .map-overlay-close:focus {
    outline: none !important;
    box-shadow: none !important;
  }

  .map-overlay-close:focus-visible {
    outline: 3px solid #ffdd00 !important;
    outline-offset: 0;
    box-shadow: inset 0 0 0 4px #0b0c0c !important;
  }

  /* Search toggle button */
  .map-search-toggle {
    background: white !important;
    border: 2px solid rgba(0, 0, 0, 0.1) !important;
    border-radius: 0 !important;
    cursor: pointer;
    padding: 0 !important;
    width: 40px !important;
    height: 40px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1) !important;
    box-sizing: border-box !important;
  }

  .map-search-toggle img {
    width: 24px !important;
    height: 24px !important;
    display: block !important;
  }

  .map-search-toggle:hover {
    background-color: #f3f2f1 !important;
  }

  .map-search-toggle:focus {
    outline: none !important;
    box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1) !important;
  }

  .map-search-toggle:focus-visible {
    outline: 3px solid #ffdd00 !important;
    outline-offset: 0 !important;
    box-shadow: inset 0 0 0 4px #0b0c0c !important;
  }

  /* Search container positioning - absolute so it appears at same position as toggle */
  #search-container {
    position: absolute;
    top: 0;
    left: 0;
    margin-top: 0;
  }

  /* Legend toggle button */
  .map-legend-toggle {
    background: white !important;
    border: 2px solid rgba(0, 0, 0, 0.1) !important;
    border-radius: 0 !important;
    cursor: pointer;
    padding: 0 !important;
    width: 40px !important;
    height: 40px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1) !important;
    box-sizing: border-box !important;
  }

  .map-legend-toggle img {
    width: 24px !important;
    height: 24px !important;
    display: block !important;
  }

  .map-legend-toggle:hover {
    background-color: #f3f2f1 !important;
  }

  .map-legend-toggle:focus {
    outline: none !important;
    box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1) !important;
  }

  .map-legend-toggle:focus-visible {
    outline: 3px solid #ffdd00 !important;
    outline-offset: 0 !important;
    box-shadow: inset 0 0 0 4px #0b0c0c !important;
  }

  /* Search overlay positioning */
  #search-overlay {
    position: absolute !important;
    top: 10px !important;
    left: 10px !important;
    z-index: 15; /* Higher than legend overlay so search results appear on top */
  }

  /* Legend overlay positioning - below search toggle */
  #legend-overlay {
    position: absolute !important;
    top: 64px !important; /* 40px search button + 4px border + 20px gap (increased to match map controls) */
    left: 10px !important;
    z-index: 10;
  }

  /* Legend container positioning - absolute so it appears at same position as toggle */
  #legend-container {
    position: absolute;
    top: 0;
    left: 0;
    margin-top: 0;
  }

  /* Legend close button - matches popup close button */
  .map-legend-close {
    position: absolute;
    top: 10px; /* Aligned with padding */
    right: 4px; /* Aligned with padding */
    background: none;
    border: none;
    font-size: 34px; /* Match popup close button */
    line-height: 1;
    padding: 0;
    width: 30px; /* Match popup close button */
    height: 30px; /* Match popup close button */
    cursor: pointer;
    color: #0b0c0c;
    font-weight: normal;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .map-legend-close:hover {
    background-color: #f3f2f1;
  }

  .map-legend-close:focus {
    outline: 3px solid #ffdd00;
    outline-offset: 0;
    box-shadow: inset 0 0 0 4px #0b0c0c;
  }

  .govuk-button {
    font-size: 1rem;
    line-height: 1.25;
    margin-bottom: 3px;
  }
  
  .govuk-checkboxes__hint {
    margin-top: -14px;
  }
  
  #parcel-filter {
    font-size: 1rem;
    line-height: 1.25;
    text-transform: uppercase;
  }

  /* Maplibre popup styles */
  .maplibregl-popup {
    pointer-events: none !important;
  }

  .maplibregl-popup-content {
    padding: 15px 20px;
    font-size: 1rem;
    line-height: 1.25;
    min-width: 200px;
    font-family: "GDS Transport", arial, sans-serif;
    pointer-events: auto !important;
  }

  .maplibregl-popup-tip {
    pointer-events: auto !important;
  }

  .maplibregl-popup-content:focus {
    outline: none !important;
  }

  .maplibregl-popup-content strong {
    font-size: 1.1875rem;
    line-height: 1.25;
    display: block;
    margin-bottom: 2px;
    font-weight: 700;
  }

  .maplibregl-popup-close-button {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 34px;
    line-height: 1;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #0b0c0c;
    font-family: "GDS Transport", arial, sans-serif;
    pointer-events: auto !important;
    cursor: pointer !important;
    z-index: 10 !important;
    background: none !important;
    border: none !important;
  }

  .maplibregl-popup-close-button:hover {
    background-color: #f3f2f1 !important;
  }

  .maplibregl-popup-close-button:focus {
    outline: none !important;
    background-color: transparent !important;
  }

  .maplibregl-popup-close-button:focus-visible {
    outline: 3px solid #ffdd00 !important;
    outline-offset: 0;
    background-color: #ffdd00 !important;
  }

/* Collapsed overlay state */
.map-overlay-collapsed {
  width: auto;
  height: auto;
  padding: 0; /* Changed from 5px to 0 */
  overflow: visible;
  max-width: none;
}

  .map-overlay-collapsed * {
    display: none;
  }

  .map-overlay-collapsed .map-overlay-close {
    display: flex !important;
    position: static;
    margin: 0;
  }

/* Map style toggle button - positioned above zoom controls */
.map-style-toggle {
  position: absolute;
  top: 10px; /* Position at top with same margin as zoom controls */
  right: 10px;
  z-index: 1;
  background: white;
  border: 2px solid rgba(0, 0, 0, 0.1);
  border-radius: 0;
  cursor: pointer;
  padding: 8px;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1);
  box-sizing: border-box;
}

.map-style-toggle img {
  width: 24px;
  height: 24px;
  display: block;
}

.map-style-toggle:hover {
  background-color: #f3f2f1;
}

.map-style-toggle:focus {
  outline: none !important;
  box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1) !important;
}

.map-style-toggle:focus-visible {
  outline: 3px solid #ffdd00 !important;
  outline-offset: 0;
  box-shadow: inset 0 0 0 4px #0b0c0c !important;
}

/* Custom zoom controls */
.custom-zoom-controls {
  position: absolute;
  top: 64px; /* 40px style toggle + 4px border + 20px gap (increased from 10px) */
  right: 10px;
  z-index: 1;
  display: flex;
  flex-direction: column;
  gap: 0;
  background: white;
  border: 2px solid rgba(0, 0, 0, 0.1);
  border-radius: 0;
  box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1), 0 0 12px rgba(0, 0, 0, 0.1);
}

.custom-zoom-button {
  background: white;
  border: none;
  cursor: pointer;
  padding: 0;
  width: 36px; /* Reduced from 40px so total with 2px border = 40px */
  height: 36px; /* Reduced from 40px so total with 2px border = 40px */
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  color: #0b0c0c;
}

.custom-zoom-button:first-child {
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.custom-zoom-button svg {
  width: 24px;
  height: 24px;
  stroke-width: 2;
}

.custom-zoom-button:hover {
  background-color: #f3f2f1;
}

.custom-zoom-button:focus {
  outline: none;
}

.custom-zoom-button:focus-visible {
  outline: 3px solid #ffdd00;
  outline-offset: 0;
  box-shadow: inset 0 0 0 4px #0b0c0c;
}

#map {
  opacity: 0;
  transition: opacity 0.3s ease-in;
}

#map.ready {
  opacity: 1;
}

/* Map loading overlay */
.map-loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #f3f2f1;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.map-loading-content {
  text-align: left;
  padding: 30px;
}

.map-loading-content .govuk-heading-m {
  margin-bottom: 15px;
}

.map-loading-content .govuk-body {
  margin-bottom: 0;
  color: #505a5f;
}

/* Full-width layout styles */
.govuk-header__container, .govuk-width-container, .app-full-width-container {
  max-width: 100%; /* Makes the container full width */
  padding: 0 15px; /* Adds a bit of padding on the sides for spacing on large screens */
}

.govuk-grid-column-one-third {
  padding-left: 0;
}
</style>
{% endblock %}